# 从零开始编写一个浏览器笔记脚本

> 故事的开始：
>
> 在浏览器上学习时时常要记笔记。
>
> 在预览网络上已有的各类插件后本人发现，这类插件往往已经长时间失去维护，或需要付费使用。
>
> 为什么不自己制作一个有类似功能的脚本呢？
>
> 在几乎没有任何理论知识的前提下本人决定实施这个构想。

## 一、开始前的准备

### 希望实现的功能

基本功能：

- [ ] 能够在网页上编写笔记，并保存在本地。可以在网页后显示对应笔记。
- [ ] 能够使用 Markdown 语法并实现实时渲染 $\LaTeX$ 。
- [ ] 能够导出与导入 Markdown 笔记。
- [ ] 能够调整笔记框的大小。

进阶功能：

- [ ] 美化笔记框背景。
- [ ] 可以根据网页中的某条内容链接到笔记的某一部分。
- [ ] 可以根据视频的进度链接到笔记。
- [ ] 自定义笔记框。
- [ ] （待思考）

### 实现方案

1、使用 **Tampermonkey** 编写基本主体脚本。这需要学习一部分网页前端知识。

2、使用开源的纯前端 Markdown 文字编辑器。

3、利用 **Git** 进行版本控制与脚本的发布。

## 二、让我们开始吧

尝试了解 **Tampermonkey**，发现官方文档没有进行汉化，因此翻阅了中文的[油猴开发指南](https://learn.scriptcat.org/简介/)。

### 1、对头部元数据的理解

| 元数据                                           | 值                                                           |
| ------------------------------------------------ | ------------------------------------------------------------ |
| `@name( :zh-CN :zh-TW :en )`                     | 脚本的名字(简中，繁中，英文)。                               |
| `@namespace`                                     | 一般为一个 URL 或自定义的内容，用于脚本管理器在`@name`相同的情况下识别唯一的脚本 |
| `@version`                                       | 脚本的版本。                                                 |
| `@author `                                       | 脚本作者。                                                   |
| `@description( :zh-CN :zh-YW :en )`              | 脚本的描述(简中，繁中，英文)。                               |
| `@include`                                       | 脚本应该运行的页面， 可以使用**通配符**， 允许多个标签。     |
| `@match`                                         | 与@include相似，区别是不可以用通配符，更精确因此更为常用，允许多个标签。 |
| `@exclude`                                       | 排除URL，即使它们包含在@include或@match中 ，允许多个标签。   |
| `@icon  @iconURL` `@defaulticon`                 | 脚本的图标的 URL，会在脚本管理列表上显示。                   |
| `@icon64` `@icon64URL`                           | 64*64 的图标文件的 URL ，可能会在选项中缩放。                |
| `@updateURL`                                     | 更新脚本的地址，该URL应该指向一个脚本文件，只需要定期更新该文件即可实现对脚本的更新。注意：只有存在@version标签才会去更新。 |
| `@downloadURL`                                   | 定义脚本的下载地址（一般指的是手动安装脚本时的文件）通常和 `@updateURL` 指向同一文件较常见。 |
| `@license`                                       | 用于声明脚本的**许可证类型**。许可证定义了其他人如何使用、修改和分发你的脚本。 |
| `@grant`                                         | 声明脚本会用到的**特殊权限或功能**。它决定了脚本是否可以使用某些特定的 API，或者是否可以访问用户脚本管理器提供的功能。可以存在多条 |
| `@require`                                       | 指向一个脚本文件，会在本脚本运行前加载并执行                 |
| `@run-at`                                        | 定义脚本被注入的时间，与其他脚本处理相反，`@run-at` 定义了脚本要运行的第一可能时间。这意味着，使用`@require`标记的脚本可能会在文档已加载后执行，因为获取所需脚本花费了很长时间。 |
| `@supportURL`                                    | 插件个人支持的地址，用于提交 issue 。                        |
| `@homepage` `@homepageURL` `@website`  `@source` | 在“选项”页上用于从脚本名链接到给定页的作者主页。请注意，如果@namespace标记以“http://”开头，则其内容也将用于此操作。 |
| `@connect`                                       | 用于声明可以与那些外部的域名进行跨域通信，未声明的域名在脚本中将被禁止访问，允许多个标签。可以使用`@connect *`允许所有域名（不推荐，可能带来安全风险）。 |

**部分元数据的常用值**

①关于`@license`常见的许可证类型：

| **许可证**      | **作用/特点**                                                |
| --------------- | ------------------------------------------------------------ |
| **MIT**         | 允许几乎任何使用，包括修改、分发和商业用途，只需保留原作者声明。 |
| **GNU GPL-3.0** | 允许修改和分发，但要求开源修改后的版本，适合需要保持自由传播的软件。 |
| **Apache-2.0**  | 类似于 MIT，但要求保留通知文件，并保护专利权。               |
| **CC-BY-4.0**   | 允许分享和修改，只需署名原作者，常用于非软件内容。           |
| **Unlicense**   | 放弃所有版权，允许任何用途。                                 |
| **WTFPL**       | `Do What The Fuck You Want To Public License`中文译：你他妈的想干嘛就干嘛公共许可证。是一种不太常用的、极度放任的自由软件许可证。它的条款基本等同于贡献到公有领域。 |
| **Custom**      | 自定义声明，允许作者明确指定特殊的版权声明，例如：`仅供个人使用，禁止修改传播`。 |

②`@grant` 的常用值

| **@grant 值**              | **描述**                                                   |
| -------------------------- | ---------------------------------------------------------- |
| `none`                     | 不授予任何特殊权限，脚本与页面共享相同的全局作用域。       |
| `GM_addStyle`              | 向页面动态添加 CSS 样式。                                  |
| `GM_getValue`              | 从脚本的本地存储中获取数据。                               |
| `GM_setValue`              | 将数据存储到脚本的本地存储中。                             |
| `GM_deleteValue`           | 删除脚本本地存储中的数据。                                 |
| `GM_listValues`            | 获取所有存储值的键名列表。                                 |
| `GM_xmlhttpRequest`        | 发起跨域的 HTTP 请求（比原生的 `XMLHttpRequest` 更强大）。 |
| `GM_download`              | 下载文件到本地。                                           |
| `GM_notification`          | 在桌面弹出通知。                                           |
| `GM_openInTab`             | 在新标签页中打开一个链接。                                 |
| `GM_registerMenuCommand`   | 向用户脚本菜单添加自定义选项。                             |
| `GM_unregisterMenuCommand` | 删除自定义的菜单选项。                                     |
| `GM_setClipboard`          | 将内容复制到系统剪贴板。                                   |
| `GM_info`                  | 提供有关用户脚本的信息（只读）。                           |

③`@run-at`的常用值

| **@run-at 值**   | **描述**                                                     |
| ---------------- | ------------------------------------------------------------ |
| `document-start` | 脚本会被尽可能快地注入                                       |
| `document-body`  | 当body元素存在是被注入                                       |
| `document-end`   | 当 DOMContentLoaded 事件被触发时或者之后注入                 |
| `document-idle`  | 当 DOMContentLoaded 事件被触发后被注入 如果没有@run-at标签也是在此时注入 |

### 2、目前产生的问题（ChatGPT 解答）

##### **Q.1：@downloadURL和@updateURL的区别**

> 在编写油猴（Tampermonkey 或 Greasemonkey）脚本时，`@include` 和 `@match` 是用来定义脚本作用范围的元数据注释。它们的作用类似，但有一些关键区别：
>
> ------
>
> ### **@include**
>
> - **用途**：匹配指定的 URL 模式，让脚本在符合模式的页面上运行。
>
> - **语法**：支持通配符（*），简单易用。
>
>   - `*`：匹配任意字符。
>
>   - 示例：
>
>     ```javascript
>     // 脚本会在所有以 "https://example.com/" 开头的页面上运行
>     @include https://example.com/*
>     ```
>
> - 匹配示例：
>
>   - ```
>     https://example.com/*
>     ```
>
>      可以匹配：
>
>     - `https://example.com/page1`
>     - `https://example.com/page2`
>
>   - 通配符 *也可以放在中间或末尾，如：
>
>     - `https://*.example.com/*` 匹配所有子域名。
>
> ------
>
> ### **@match**
>
> - **用途**：更严格地匹配 URL 模式，符合 URL 模式规范。
>
> - **语法**：不支持简单的 * 通配符定义所有，而是更精确的匹配规则。
>
>   - 但可以使用通配符 `*` 匹配子域名或协议。
>
>   - 示例：
>
>     ```
>     javascript复制代码// 脚本会在 https://example.com 的所有页面运行
>     @match https://example.com/*
>     ```
>
> - 匹配示例：
>
>   - ```
>     https://*.example.com/*
>     ```
>
>      可以匹配：
>
>     - `https://sub.example.com/page`
>     - `https://another.example.com/page`
>
>   - 但不会匹配：
>
>     - `http://example.com`（因为协议不同）。
>
> ------
>
> ### **关键区别**
>
> | 特性         | `@include`             | `@match`                                |
> | ------------ | ---------------------- | --------------------------------------- |
> | **灵活性**   | 支持简单通配符，较宽松 | 严格匹配 URL，符合标准规范              |
> | **安全性**   | 容易出现误匹配         | 更严格，减少误匹配的风险                |
> | **协议要求** | 可以省略协议           | 必须指定协议（`http://` 或 `https://`） |
> | **兼容性**   | 旧版脚本可能使用更多   | 推荐使用，符合现代浏览器扩展规范        |
>
> ------
>
> ### **使用建议**
>
> 1. 如果需要快速定义作用域，且 URL 规则较简单，可以使用 `@include`。
> 2. 如果需要更安全、更准确的匹配，建议使用 `@match`，特别是在现代浏览器扩展环境下。
>
> > 现代浏览器和 Tampermonkey 都更推荐使用 `@match`，因为它的匹配规则符合浏览器扩展的标准。
>
> ### 个人总结
>
> 两者用来将脚本应用到所有的页面，应分别如下写：
>
> `@match        *://*/*`
>
> `@include	   *`

#####  Q.2：什么是 DOMContentLoaded 事件？

> `DOMContentLoaded` 是一个常见的 JavaScript 事件，用于监听 HTML 文档的加载状态。当浏览器解析完所有的 HTML 并构建完成 DOM 树时，就会触发 `DOMContentLoaded` 事件，而无需等待其他资源（如图片、样式表和脚本文件）的加载完成。
>
> ------
>
> ### **特点**
>
> 1. **触发时机**：当 HTML 文档被完全加载和解析完成时（即 DOM 树构建完成）。
> 2. **不等待其他资源**：与 `window.onload` 不同，`DOMContentLoaded` 不需要等待图片、样式表、iframe 等资源加载完成后才触发。
> 3. **适用于操作 DOM**：在该事件触发时，DOM 已经可用，因此适合初始化页面内容或操作 DOM 元素。
>
> ------
>
> ### **用法**
>
> 监听 `DOMContentLoaded` 的方法有以下几种：
>
> #### **1. 使用 `addEventListener`**
>
> ```javascript
> document.addEventListener("DOMContentLoaded", function() {
>     console.log("DOM 已完全加载并解析");
>     // 可以安全地操作 DOM 元素
>     document.body.style.backgroundColor = "lightblue";
> });
> ```
>
> #### **2. 使用旧的 `onreadystatechange`**
>
> 早期浏览器中，可以通过 `readyState` 属性判断文档是否加载完成：
>
> ```javascript
> document.onreadystatechange = function() {
>     if (document.readyState === "interactive") {
>         console.log("DOM 已完全加载并解析");
>     }
> };
> ```
>
> #### **3. 直接在脚本末尾执行**
>
> 如果你的脚本放在文档的底部（`</body>`标签之前），可以不显式监听 `DOMContentLoaded`，因为此时 DOM 已经解析完成：
>
> ```html
> <!DOCTYPE html>
> <html>
> <head>
>     <title>Example</title>
> </head>
> <body>
>     <h1>Hello, World!</h1>
>     <script>
>         console.log(document.querySelector("h1").textContent); // "Hello, World!"
>     </script>
> </body>
> </html>
> ```
>
> ------
>
> ### **`DOMContentLoaded` 和 `window.onload` 的区别**
>
> | 特性                 | `DOMContentLoaded`                    | `window.onload`                            |
> | -------------------- | ------------------------------------- | ------------------------------------------ |
> | **触发时机**         | DOM 树构建完成（HTML 已加载并解析）。 | 页面所有资源（包括图片、样式等）加载完成。 |
> | **是否等待外部资源** | 不等待外部资源加载完成。              | 等待所有外部资源加载完成。                 |
> | **使用场景**         | 初始化 DOM 操作或页面功能。           | 确保所有资源可用（如图片尺寸）。           |
>
> ------
>
> ### **示例：两者对比**
>
> ```javascript
> document.addEventListener("DOMContentLoaded", function() {
>     console.log("DOM 已加载完成，但图片可能还在加载中");
> });
> 
> window.addEventListener("load", function() {
>     console.log("页面所有资源加载完成，包括图片和样式");
> });
> ```
>
> ------
>
> ### **浏览器支持**
>
> `DOMContentLoaded` 是一个标准事件，现代浏览器（包括 IE9+）都完全支持。
>
> ------
>
> ### **使用建议**
>
> - **推荐场景**：如果你的脚本只需要操作 DOM 元素（如添加事件监听器或修改内容），优先使用 `DOMContentLoaded`，因为它比 `window.onload` 更早触发。
> - **性能优化**：通过监听 `DOMContentLoaded`，可以更快地响应用户交互，而无需等待所有资源加载完成。

##### **Q.3：什么是DOM树？**

**DOM 树**（Document Object Model Tree）是浏览器在加载和解析 HTML 文档时，根据 HTML 的层级结构生成的一种**树形数据结构**。它表示了文档的结构以及每个节点之间的关系，使得 JavaScript 可以通过 DOM API 操作页面内容和结构。

**DOM 树的组成**

> DOM 树由以下几种节点组成，每个节点代表 HTML 文档的一部分：
>
> 1. **文档节点（Document Node）**：
>    - 表示整个 HTML 文档的根节点。
>    - 通过 JavaScript 的 `document` 对象访问。
> 2. **元素节点（Element Nodes）**：
>    - 表示 HTML 的元素标签，例如 `<div>`、`<p>`。
>    - 元素节点可以嵌套形成层级结构。
> 3. **属性节点（Attribute Nodes）**：
>    - 表示 HTML 元素的属性，例如 `id="example"`。
>    - 属性是元素节点的一部分，但在 DOM 树中不是子节点，而是直接附属于对应的元素节点。
> 4. **文本节点（Text Nodes）**：
>    - 表示元素或属性中的文本内容。
>    - 文本节点始终是叶节点，没有子节点。
> 5. **注释节点（Comment Nodes）**：
>    - 表示 HTML 文档中的注释内容。
>
> ------
>
> ### **DOM 树的结构**
>
> 以以下 HTML 代码为例：
>
> ```html
> <!DOCTYPE html>
> <html>
>   <head>
>     <title>Example</title>
>   </head>
>   <body>
>     <h1 id="header">Hello, World!</h1>
>     <p>Welcome to DOM.</p>
>   </body>
> </html>
> ```
>
> 对应的 DOM 树结构如下：
>
> ```bash
> Document
>  └── html
>       ├── head
>       │     └── title
>       │           └── "Example"
>       └── body
>             ├── h1
>             │     ├── Attribute: id="header"
>             │     └── "Hello, World!"
>             └── p
>                   └── "Welcome to DOM."
> ```
>
> ------
>
> ### **DOM 树的特点**
>
> 1. **层级关系**：
>    - HTML 文档的嵌套结构会在 DOM 树中反映为父子关系。
>    - 每个 HTML 元素是一个节点，嵌套关系形成了树状层级。
> 2. **节点类型**：
>    - 可以通过 `nodeType` 属性查看节点类型，例如：
>      - `1`：元素节点
>      - `3`：文本节点
>      - `8`：注释节点
> 3. **可遍历**：
>    - DOM 树中的节点可以通过 JavaScript 遍历，例如 `parentNode`、`childNodes`、`nextSibling` 等。
>
> ------
>
> ### **常见操作**
>
> 1. **获取节点**：
>
>    ```javascript
>    const header = document.getElementById("header"); // 获取 h1 元素
>    const paragraphs = document.getElementsByTagName("p"); // 获取所有 <p> 元素
>    ```
>
> 2. **修改节点内容**：
>
>    ```javascript
>    const header = document.getElementById("header");
>    header.textContent = "Hello, DOM!";
>    ```
>
> 3. **添加新节点**：
>
>    ```javascript
>    const newDiv = document.createElement("div");
>    newDiv.textContent = "This is a new div.";
>    document.body.appendChild(newDiv);
>    ```
>
> 4. **删除节点**：
>
>    ```javascript
>    const header = document.getElementById("header");
>    header.remove();
>    ```
>
> ------
>
> ### **DOM 树的作用**
>
> 1. **页面动态交互**：通过操作 DOM 树，可以动态修改页面的结构和内容。
> 2. **事件绑定**：JavaScript 事件处理器通过 DOM 树关联 HTML 元素。
> 3. **样式动态调整**：通过修改 DOM 节点的样式属性实现动态效果。
>
> ------
>
> ### **总结**
>
> DOM 树是 HTML 文档在浏览器中的表示形式，它将 HTML 结构化为可以用 JavaScript 操作的对象模型。熟练掌握 DOM 树和相关操作是前端开发的基础。

2024/12/8

--------

### 3、Hello World

在头部元数据下方标注了书写代码的地方。

```javascript
(function() {
    'use strict';

// Your code here...

})();
```

根据文档描述，脚本的书写应该使用`JavaScript`。

利用`alert()`弹出一个对话框，并输出 HelloWorld，并使用`@include *`将其应用到所有页面。

```javascript
// ==UserScript==
//@name    a_simple_test
//@include *
// ==/UserScript==
(function() {
    'use strict';
	alert('HelloWorld')
// Your code here...

})();
```

这样，在打开任意网站后，都会弹出一个 HelloWorld 的对话框。

### 4、熟悉  JavaScript  的语法

在[JavaScript 用法 | 菜鸟教程](https://www.runoob.com/js/js-howto.html)中了解JS的基本用法。

在此出现的问题：

##### **Q.4：之前 HelloWorld 脚本中的`alert('HelloWorld')`末尾没有分号，这种写法是否合法？**

> 是合法的！在 JavaScript 中，分号（`;`）是**可选的**，因为 JavaScript 有一个**自动分号插入（Automatic Semicolon Insertion, ASI）**的机制。在大多数情况下，即使你省略了分号，JavaScript 引擎也会根据上下文自动插入。
>
> ------
>
> ### **解释代码中的 `alert('HelloWorld')`**
>
> 在以下代码中：
>
> ```javascript
> alert('HelloWorld')
> ```
>
> 即使没有写分号，JavaScript 引擎仍然能正确解析，因为：
>
> 1. `alert('HelloWorld')` 是一个独立的语句。
>
> 2. ASI 机制会在行末自动插入分号，等效于：
>
>    ```javascript
>    alert('HelloWorld');
>    ```
>
> 因此，这种省略分号的写法是合法的。
>
> ------
>
> ### **什么时候分号是必要的？**
>
> 尽管 ASI 机制可以避免大部分语法错误，但在某些特定情况下，**省略分号可能导致意外行为**。例如：
>
> #### 情况 1：行首是 `[` 或 `(` 的表达式
>
> ```javascript
> let a = 5
> [1, 2, 3].forEach(x => console.log(x))
> ```
>
> 在这种情况下，JavaScript 会将 `[1, 2, 3]` 视为数组访问器，而不是独立的数组字面量。
>
> 解决方法：
>
> ```javascript
> let a = 5;
> [1, 2, 3].forEach(x => console.log(x));
> ```
>
> #### 情况 2：返回值与表达式在不同行
>
> ```javascript
> function test() {
>     return
>     {
>         value: 42
>     }
> }
> console.log(test()) // undefined
> ```
>
> 在这种情况下，`return` 语句后自动插入了分号，因此实际返回的是 `undefined`。
>
> 解决方法：
>
> ```javascript
> function test() {
>     return {
>         value: 42
>     };
> }
> ```
>
> ------
>
> ### **建议**
>
> 1. **始终使用分号**：虽然 JavaScript 的 ASI 机制可以省略分号，但为了代码的可读性和避免潜在的错误，建议显式添加分号。
> 2. **遵循团队规范**：如果项目使用了某种代码风格（如 Airbnb 或 Standard），遵循其规范（例如 Standard JS 就不使用分号）。
> 3. **工具辅助**：使用代码检查工具（如 ESLint）和格式化工具（如 Prettier）来统一代码风格。
>
> ------
>
> ### **结论**
>
> 在你的脚本中，省略 `alert('HelloWorld')` 的分号是合法的，且能正确运行。不过，养成显式添加分号的习惯会更安全、更规范。

### 5、（番外）为插件创作一个图标

使用 ChatGPT 绘制一个笔记本的图标，将其转换为64*64大小。

使用 [SVG 在线编辑器 | 菜鸟工具](https://www.jyshare.com/more/svgeditor/) 将其转化为矢量图形，并使其可以用代码表示出来。

发现 ChatGPT 绘制的图形不是纯色图形，会导致代码过长，故放弃使用 ChatGPT 绘制的图形，转而使用网络上公开的资源。

再次使用 SVG 工具将其稍加修改得到以下图形。

<svg xmlns="http://www.w3.org/2000/svg" width="512" height="512" enable-background="new 0 0 512 512">
 <g>
  <title>Layer 1</title>
  <rect id="svg_5" height="571.99998" width="596.99998" y="-40.33333" x="-61.00001" stroke="#000" fill="#007fff"/>
  <g stroke="null" id="svg_1">
   <path fill="#ffffff" stroke="null" d="m405.57838,11l-294.55034,0c-13.73215,0 -24.90382,11.59156 -24.90382,25.83984l0,36.19588l-14.81777,0c-7.64086,0 -13.83545,6.42742 -13.83545,14.35547s6.19459,14.35547 13.83545,14.35547l14.81777,0l0,55.59299l-14.81777,0c-7.64086,0 -13.83545,6.42742 -13.83545,14.35547s6.19459,14.35547 13.83545,14.35547l14.81777,0l0,55.59394l-14.81777,0c-7.64086,0 -13.83545,6.42742 -13.83545,14.35547s6.19459,14.35547 13.83545,14.35547l14.81777,0l0,55.59394l-14.81777,0c-7.64086,0 -13.83545,6.42742 -13.83545,14.35547s6.19459,14.35547 13.83545,14.35547l14.81777,0l0,55.59299l-14.81777,0c-7.64086,0 -13.83545,6.42742 -13.83545,14.35547s6.19459,14.35547 13.83545,14.35547l14.81777,0l0,36.19588c0,14.24828 11.17167,25.83984 24.90382,25.83984l294.55034,0c24.23418,0 43.95062,-20.45654 43.95062,-45.60254l0,-398.79492c0,-25.146 -19.71552,-45.60254 -43.95062,-45.60254zm16.27972,444.39745c0,9.31383 -7.30235,16.8916 -16.27972,16.8916l-291.78325,0l0,-33.32478l14.81777,0c7.64086,0 13.83545,-6.42742 13.83545,-14.35547s-6.19459,-14.35547 -13.83545,-14.35547l-14.81777,0l0,-55.59299l14.81777,0c7.64086,0 13.83545,-6.42742 13.83545,-14.35547s-6.19459,-14.35547 -13.83545,-14.35547l-14.81777,0l0,-55.59394l14.81777,0c7.64086,0 13.83545,-6.42742 13.83545,-14.35547s-6.19459,-14.35547 -13.83545,-14.35547l-14.81777,0l0,-55.59394l14.81777,0c7.64086,0 13.83545,-6.42742 13.83545,-14.35547s-6.19459,-14.35547 -13.83545,-14.35547l-14.81777,0l0,-55.59299l14.81777,0c7.64086,0 13.83545,-6.42742 13.83545,-14.35547s-6.19459,-14.35547 -13.83545,-14.35547l-14.81777,0l0,-33.32478l291.78325,0c8.97644,0 16.27972,7.57682 16.27972,16.8916l0,398.79492z" id="svg_2"/>
   <path fill="#ffffff" stroke="null" d="m366.54764,410.25333l-65.9988,0c-7.64086,0 -13.83545,6.42742 -13.83545,14.35547s6.19459,14.35547 13.83545,14.35547l65.9988,0c7.64086,0 13.83545,-6.42742 13.83545,-14.35547s-6.19459,-14.35547 -13.83545,-14.35547z" id="svg_3"/>
   <path fill="#ffffff" stroke="null" d="m366.54764,73.03572l-169.12089,0c-7.64086,0 -13.83545,6.42742 -13.83545,14.35547l0,77.89469c0,7.92805 6.19459,14.35547 13.83545,14.35547l169.12089,0c7.64086,0 13.83545,-6.42742 13.83545,-14.35547l0,-77.89469c0,-7.92805 -6.19459,-14.35547 -13.83545,-14.35547zm-13.83545,77.89469l-141.44998,0l0,-49.18375l141.44998,0l0,49.18375z" id="svg_4"/>
  </g>
 </g>
接下来，将其转换为可以直接在`@icon`后使用的格式，即 **Data URI** 格式。使用在线工具[在线SVG转DataURL - UU在线工具](https://uutool.cn/svg2datauri/)自动转化。

![](data:image/svg+xml;charset=utf-8;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1MTIiIGhlaWdodD0iNTEyIiBlbmFibGUtYmFja2dyb3VuZD0ibmV3IDAgMCA1MTIgNTEyIj4KIDxnPgogIDx0aXRsZT5MYXllciAxPC90aXRsZT4KICA8cmVjdCBpZD0ic3ZnXzUiIGhlaWdodD0iNTcxLjk5OTk4IiB3aWR0aD0iNTk2Ljk5OTk4IiB5PSItNDAuMzMzMzMiIHg9Ii02MS4wMDAwMSIgc3Ryb2tlPSIjMDAwIiBmaWxsPSIjMDA3ZmZmIi8+CiAgPGcgc3Ryb2tlPSJudWxsIiBpZD0ic3ZnXzEiPgogICA8cGF0aCBmaWxsPSIjZmZmZmZmIiBzdHJva2U9Im51bGwiIGQ9Im00MDUuNTc4MzgsMTFsLTI5NC41NTAzNCwwYy0xMy43MzIxNSwwIC0yNC45MDM4MiwxMS41OTE1NiAtMjQuOTAzODIsMjUuODM5ODRsMCwzNi4xOTU4OGwtMTQuODE3NzcsMGMtNy42NDA4NiwwIC0xMy44MzU0NSw2LjQyNzQyIC0xMy44MzU0NSwxNC4zNTU0N3M2LjE5NDU5LDE0LjM1NTQ3IDEzLjgzNTQ1LDE0LjM1NTQ3bDE0LjgxNzc3LDBsMCw1NS41OTI5OWwtMTQuODE3NzcsMGMtNy42NDA4NiwwIC0xMy44MzU0NSw2LjQyNzQyIC0xMy44MzU0NSwxNC4zNTU0N3M2LjE5NDU5LDE0LjM1NTQ3IDEzLjgzNTQ1LDE0LjM1NTQ3bDE0LjgxNzc3LDBsMCw1NS41OTM5NGwtMTQuODE3NzcsMGMtNy42NDA4NiwwIC0xMy44MzU0NSw2LjQyNzQyIC0xMy44MzU0NSwxNC4zNTU0N3M2LjE5NDU5LDE0LjM1NTQ3IDEzLjgzNTQ1LDE0LjM1NTQ3bDE0LjgxNzc3LDBsMCw1NS41OTM5NGwtMTQuODE3NzcsMGMtNy42NDA4NiwwIC0xMy44MzU0NSw2LjQyNzQyIC0xMy44MzU0NSwxNC4zNTU0N3M2LjE5NDU5LDE0LjM1NTQ3IDEzLjgzNTQ1LDE0LjM1NTQ3bDE0LjgxNzc3LDBsMCw1NS41OTI5OWwtMTQuODE3NzcsMGMtNy42NDA4NiwwIC0xMy44MzU0NSw2LjQyNzQyIC0xMy44MzU0NSwxNC4zNTU0N3M2LjE5NDU5LDE0LjM1NTQ3IDEzLjgzNTQ1LDE0LjM1NTQ3bDE0LjgxNzc3LDBsMCwzNi4xOTU4OGMwLDE0LjI0ODI4IDExLjE3MTY3LDI1LjgzOTg0IDI0LjkwMzgyLDI1LjgzOTg0bDI5NC41NTAzNCwwYzI0LjIzNDE4LDAgNDMuOTUwNjIsLTIwLjQ1NjU0IDQzLjk1MDYyLC00NS42MDI1NGwwLC0zOTguNzk0OTJjMCwtMjUuMTQ2IC0xOS43MTU1MiwtNDUuNjAyNTQgLTQzLjk1MDYyLC00NS42MDI1NHptMTYuMjc5NzIsNDQ0LjM5NzQ1YzAsOS4zMTM4MyAtNy4zMDIzNSwxNi44OTE2IC0xNi4yNzk3MiwxNi44OTE2bC0yOTEuNzgzMjUsMGwwLC0zMy4zMjQ3OGwxNC44MTc3NywwYzcuNjQwODYsMCAxMy44MzU0NSwtNi40Mjc0MiAxMy44MzU0NSwtMTQuMzU1NDdzLTYuMTk0NTksLTE0LjM1NTQ3IC0xMy44MzU0NSwtMTQuMzU1NDdsLTE0LjgxNzc3LDBsMCwtNTUuNTkyOTlsMTQuODE3NzcsMGM3LjY0MDg2LDAgMTMuODM1NDUsLTYuNDI3NDIgMTMuODM1NDUsLTE0LjM1NTQ3cy02LjE5NDU5LC0xNC4zNTU0NyAtMTMuODM1NDUsLTE0LjM1NTQ3bC0xNC44MTc3NywwbDAsLTU1LjU5Mzk0bDE0LjgxNzc3LDBjNy42NDA4NiwwIDEzLjgzNTQ1LC02LjQyNzQyIDEzLjgzNTQ1LC0xNC4zNTU0N3MtNi4xOTQ1OSwtMTQuMzU1NDcgLTEzLjgzNTQ1LC0xNC4zNTU0N2wtMTQuODE3NzcsMGwwLC01NS41OTM5NGwxNC44MTc3NywwYzcuNjQwODYsMCAxMy44MzU0NSwtNi40Mjc0MiAxMy44MzU0NSwtMTQuMzU1NDdzLTYuMTk0NTksLTE0LjM1NTQ3IC0xMy44MzU0NSwtMTQuMzU1NDdsLTE0LjgxNzc3LDBsMCwtNTUuNTkyOTlsMTQuODE3NzcsMGM3LjY0MDg2LDAgMTMuODM1NDUsLTYuNDI3NDIgMTMuODM1NDUsLTE0LjM1NTQ3cy02LjE5NDU5LC0xNC4zNTU0NyAtMTMuODM1NDUsLTE0LjM1NTQ3bC0xNC44MTc3NywwbDAsLTMzLjMyNDc4bDI5MS43ODMyNSwwYzguOTc2NDQsMCAxNi4yNzk3Miw3LjU3NjgyIDE2LjI3OTcyLDE2Ljg5MTZsMCwzOTguNzk0OTJ6IiBpZD0ic3ZnXzIiLz4KICAgPHBhdGggZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJudWxsIiBkPSJtMzY2LjU0NzY0LDQxMC4yNTMzM2wtNjUuOTk4OCwwYy03LjY0MDg2LDAgLTEzLjgzNTQ1LDYuNDI3NDIgLTEzLjgzNTQ1LDE0LjM1NTQ3czYuMTk0NTksMTQuMzU1NDcgMTMuODM1NDUsMTQuMzU1NDdsNjUuOTk4OCwwYzcuNjQwODYsMCAxMy44MzU0NSwtNi40Mjc0MiAxMy44MzU0NSwtMTQuMzU1NDdzLTYuMTk0NTksLTE0LjM1NTQ3IC0xMy44MzU0NSwtMTQuMzU1NDd6IiBpZD0ic3ZnXzMiLz4KICAgPHBhdGggZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJudWxsIiBkPSJtMzY2LjU0NzY0LDczLjAzNTcybC0xNjkuMTIwODksMGMtNy42NDA4NiwwIC0xMy44MzU0NSw2LjQyNzQyIC0xMy44MzU0NSwxNC4zNTU0N2wwLDc3Ljg5NDY5YzAsNy45MjgwNSA2LjE5NDU5LDE0LjM1NTQ3IDEzLjgzNTQ1LDE0LjM1NTQ3bDE2OS4xMjA4OSwwYzcuNjQwODYsMCAxMy44MzU0NSwtNi40Mjc0MiAxMy44MzU0NSwtMTQuMzU1NDdsMCwtNzcuODk0NjljMCwtNy45MjgwNSAtNi4xOTQ1OSwtMTQuMzU1NDcgLTEzLjgzNTQ1LC0xNC4zNTU0N3ptLTEzLjgzNTQ1LDc3Ljg5NDY5bC0xNDEuNDQ5OTgsMGwwLC00OS4xODM3NWwxNDEuNDQ5OTgsMGwwLDQ5LjE4Mzc1eiIgaWQ9InN2Z180Ii8+CiAgPC9nPgogPC9nPgoKPC9zdmc+)



### 6、创建一个唤出笔记本的标识

我们需要一个拥有以下功能的标识：

- 在浏览器页面的边框处，并始终位于页面最上方。
- 点击后会唤出笔记本。
- 拥有一些简单的动画效果。
- 随页面滚动时不改变标识的位置。

首先要知道如何使用 JavaScript 创建并插入 HTML 元素。

查阅了[HTML DOM insertAdjacentHTML() 方法 - 菜鸟教程](https://www.cainiaojc.com/jsref/elem_insertadjacenthtml.html)，[HTML DOM querySelector() 方法 | 菜鸟教程](https://www.runoob.com/jsref/met-document-queryselector.html)。

```JS
document.querySelector("body").insertAdjacentHTML("afterend", "<div><p>Hello world</p></div>");
//表示在<body>元素后插入<div>元素。先用querySelector()获取<body>元素的document，再用insertAdjacentHTML(,)插入元素。
```

现在我们要将这个元素置于我们希望它存在的位置，为此，我们需要了解如何利用脚本改变元素的 CSS 样式，以及如何书写 CSS。

设置位置查阅的资料：[CSS position 属性 | 菜鸟教程](https://www.runoob.com/cssref/pr-class-position.html)、[CSS bottom 属性 | 菜鸟教程](https://www.runoob.com/cssref/pr-pos-bottom.html)、[使用css，如何把div设置为圆形-百度经验](https://jingyan.baidu.com/article/f3ad7d0fa974c749c3345bff.html#:~:text=不需要使用图片，直接使用div%2Bcss就可以创建一个圆形了，下面来看一下是怎么创建的。 先创建一个div，有一个circle样式的欧泉。 为div创建样式，添加border边框，长度和宽度。,运行页面，帽泛现在div是一个四方形的形状。 再在样式里添加一个border-radius边框弧度的样式，设置为30像素。 运行页面，可以看到div现在差不多是一个圆形了。)、[CSS border 属性 | 菜鸟教程](https://www.runoob.com/cssref/pr-border.html)

```JS
    document.querySelector("body").insertAdjacentHTML("afterbegin",'<div id="nicoBt"><p>helloworld</></div>');
    //表示在<body>元素后插入<div>元素
    var nicoButton = document.getElementById("nicoBt");
    //var 表示定义变量，根据getElementById()利用id找到<div>元素
    var nicoButtonStyle = "\
    position: fixed;\
    right: 1%;\
    bottom:80%;\
    width: 44px;\
    height: 44px;\
    border: 2px solid #D3D3D3;\
    border-radius: 50%;\
    background: rgb(0, 127, 255);\
    z-index: 2147483647;\
    ";
    //第一句表示依照浏览器边框定位，right与bottom定义位置，width与height定义长宽，border用于定义边框，border-radius用于实现圆形效果,z-index定义了元素的图层高度，设置一个很大的数字可以保证其置于其他图像上方。
    //定义<div>元素的CSS样式，输入字符串时进行换行操作,在每行末尾加上\
    //末尾的;可加可不加
    nicoButton.setAttribute("style",nicoButtonStyle);
    //setAttribute(,)可以改变元素属性，用来改变nicoButton的CSS样式

```

现在我们把这个<div>元素改写为一个按钮，把图标插入进去。

```JS
var htmlNicoButton = '\
<div id="nicoBt">\
		<img src="图标URL">\
</div>\
';
document.querySelector("body").insertAdjacentHTML("afterbegin",htmlNicoButton);
//以下略
```

2024/12/9

-----

```CSS
    position: absolute;/*使用相对位置*/
    top: 50%;/*竖直方向上一半*/
    left: 50%;/*水平方向上一半*/
    transform: translate(-50%, -50%);/*x,y方向上均往回移动自身的一般*/
```

使用上面的方法把图像居中，参考：[CSS3 transform 属性 | 菜鸟教程](https://www.runoob.com/cssref/css3-pr-transform.html)

发现存在<iframe>时会添加很多的标识，希望只在主页面添加，加上判断：

```JS
    if (window.self === window.top) {
        document.querySelector("body").insertAdjacentHTML("afterend",htmlNicoButton);
    }
```

参考了[JavaScript 比较和逻辑运算符 | 菜鸟教程](https://www.runoob.com/js/js-comparisons.html)、[Window self 属性 | 菜鸟教程](https://www.runoob.com/jsref/prop-win-self.html)

下面我们要让鼠标悬停在标识上方时有一定的反馈效果，这里利用了`addEventListener()`设置两个效果，参考了[HTML DOM addEventListener() 方法 | 菜鸟教程](https://www.runoob.com/jsref/met-document-addeventlistener.html)。

```js
    nicoButton.addEventListener("mouseover", function () { //光标移动到图标上，执行函数
        nicoButton.style.width = "55px";
        nicoButton.style.height = "55px";
        //大小改变
        nicoButton.style.cursor = "pointer";
        //鼠标光标从箭头改编为小手
    });

    nicoButton.addEventListener("mouseout", function () { //光标移开
        nicoButton.style.width = "48px";
        nicoButton.style.height = "48px";
        nicoButton.style.cursor = "";
        //变回
    });

```

### 7、创建笔记本！

使用开源项目 [Vditor](https://github.com/Vanessa219/vditor) ,根据开发者文档尝试在 HTML 中引入 vditor 。

```html
<!-- ⚠️生产环境请指定版本号，如 https://unpkg.com/vditor@x.x.x/dist... -->
<link rel="stylesheet" href="https://unpkg.com/vditor/dist/index.css" />
<script src="https://unpkg.com/vditor/dist/index.min.js"></script>
```

把这行代码写入<head>中：

```js
    document.querySelector("head").insertAdjacentHTML("afterbegin",headVditorCode);
```

##### **Q.5：之前讲过用`@require`加载脚本，这里可以那样做吗？**

> 可以，且**更推荐使用`@require`的方式**，因为如果你在插入资源后立即使用 Vditor，可能会因为资源未加载完成而报错，并且动态插入 HTML 字符串不够直观，可能会增加代码阅读和维护的难度。
>
> 但是**`@require`只能用来加载 JS 而不能用于 CSS **使用`GM_addStyle`可以解决这一问题。
>
> ```js
> // ==UserScript==
> // @name         Vditor Integration with CSS
> // @namespace    http://tampermonkey.net/
> // @version      1.0
> // @description  Integrate Vditor
> // @author       Your Name
> // @match        *://*/*
> // @require      https://cdn.jsdelivr.net/npm/vditor/dist/index.min.js
> // @grant        GM_addStyle
> // ==/UserScript==
> 
> // 使用 GM_addStyle 插入 CSS 样式
> GM_addStyle(`
> @import url('https://cdn.jsdelivr.net/npm/vditor/dist/index.css');
> `);
> ```
>
> 如果你坚持使用动态插入方式，建议优化为分步加载，避免时序问题：
>
> ```javascript
> // 动态加载 CSS
> var link = document.createElement('link');
> link.rel = 'stylesheet';
> link.href = 'https://unpkg.com/vditor/dist/index.css';
> document.head.appendChild(link);
> 
> // 动态加载 JS
> var script = document.createElement('script');
> script.src = 'https://unpkg.com/vditor/dist/index.min.js';
> script.onload = function () {
>     // 确保 Vditor 加载完成后再初始化
>     new Vditor('editor', {
>         height: 300,
>         placeholder: 'Write something...',
>     });
> };
> document.head.appendChild(script);
> ```
>
> 这种方式更易维护，且避免 HTML 字符串操作的潜在问题。

创建一个<div>作为我们的笔记本框：

```js
    var nicoNoteDiv = document.createElement("div");//这里用document.creatElement()创建元素。ps.比最开始进步了
    nicoNoteDiv.setAttribute("id","nicoNoteDiv");
```

用点击事件呼出编辑框，并让图标不透明度降低（参考[css中让元素消失的方法_transition visibility 无效-CSDN博客](https://blog.csdn.net/qq_43205326/article/details/110207160)）：

```js
    nicoButton.addEventListener("click", function () {
     document.querySelector("html").appendChild(nicoNoteDiv);//用点击事件呼出编辑框,添加在 nicoBt 后面
     nicoButton.style.opacity="0.3"; //图标不透明度降低
    });
//这里用 elementA.appendChild(elemenetB)：表明在A内最后添加B元素
```

下面我们来设计这个`nicoNoteDiv`除了最基本的长宽位置之外，我们希望它可以允许自己通过拖拽调节大小和位置（似乎略有些麻烦）。

2024/12/10

---

2024/12/11 去医院了，还被坑了，详情请见：[只身陷入心理治疗骗局！！深扒“SCIO全科生物反馈测疗仪”与“心理AI智能检测”底裤。 - 知乎](https://zhuanlan.zhihu.com/p/12090143389)

---

#### ①拖拽调节位置

为了使其可以调节自身位置和大小，我们应该从两方考虑：

1. CSS 角度，在鼠标靠近<div>边缘时，光标应该发生变化。
2. JS 角度，根据鼠标光标的坐标改变<div>的大小。

为了实现上述操作，我们考虑把存放笔记本主体的<div>和调整大小的<div>分开，外层仅仅实现拖拽功能，内层为主体。

##### **Q.6:在查询资料时发现的`() => {}`是什么意思?**

> `(e) => {}` 是 JavaScript 中的箭头函数语法，是定义函数的一种简洁方式。它可以用来代替传统的 `function` 声明。
>
> ------
>
> ### **语法**
>
> ```
> javascript
> 
> 
> 复制代码
> (param1, param2, ...) => { // 函数体 }
> ```
>
> ------
>
> ### **分解理解 `(e) => {}`**
>
> 1. **箭头函数**：
>    - `=>` 是箭头函数的核心，表示这是一个函数。
> 2. **参数 `(e)`**：
>    - `e` 是箭头函数的参数。它通常代表事件对象，尤其是在事件处理程序中，比如 `addEventListener`。
> 3. **函数体 `{}`**：
>    - `{}` 包含函数执行的代码。
>
> ------
>
> ### **完整例子**
>
> 以下是一个常见的使用场景：
>
> #### **传统函数写法**
>
> ```javascript
> document.addEventListener("click", function(e) {
>     console.log("鼠标点击了页面", e);
> });
> ```
>
> #### **箭头函数写法**
>
> ```javascript
> document.addEventListener("click", (e) => {
>     console.log("鼠标点击了页面", e);
> });
> ```
>
> ------
>
> ### **简化规则**
>
> 1. **参数简写**：
>
>    - 如果只有一个参数，可以省略括号 ()
>
>      ```JS
>      e => console.log(e);
>      ```
>
>    - 如果没有参数或有多个参数，则必须使用括号。
>
>      ```javascript
>      () => console.log("无参数");
>      (x, y) => console.log(x + y);
>      ```
>
> 2. **函数体简写**：
>
>    - 如果函数体只有一行代码，且直接返回值，可以省略 {} 和 return
>
>      ```javascript
>      x => x * x; // 返回 x 的平方
>      ```
>
> ------
>
> ### **优势**
>
> - **简洁**：语法更短，易读。
> - **自动绑定上下文**：箭头函数不会创建自己的 `this`，而是继承自外层作用域。
>
> #### **例子：箭头函数绑定上下文**
>
> ```javascript
> function Example() {
>     this.name = "箭头函数示例";
>     document.addEventListener("click", () => {
>         console.log(this.name); // 指向 Example 实例
>     });
> }
> new Example();
> ```
>
> ------
>
> ### **对比传统函数**
>
> | 特性        | 箭头函数           | 普通函数                       |
> | ----------- | ------------------ | ------------------------------ |
> | 语法简洁    | 是                 | 否                             |
> | `this` 指向 | 继承外层作用域     | 动态绑定，取决于调用位置       |
> | 使用场景    | 回调函数、简单逻辑 | 需要动态绑定 `this` 的复杂场景 |
>
> 箭头函数非常适合在事件处理、数组操作等回调中使用，但如果需要灵活绑定 `this`，普通函数可能更适合。

**先实现较简单的拖拽：**

首先我们应该想办法获取鼠标的光标坐标，可以利用`addEventListener`监听`mousemove`事件，再将生成的`MouseEvent` 对象传入参数，提取`clientX` 和 `clientY`的信息。

关于这一过程的具体原理 Chat GPT 回答如下：

> 在以下代码中：
>
> ```javascript
> document.addEventListener('mousemove', (event) => { 
>   const { clientX, clientY } = event;
>   console.log(`鼠标X坐标: ${clientX}, 鼠标Y坐标: ${clientY}`);//console.log（）用于把信息输出到工作台。${}表示在字符串中插入函数或变量。
> });
> ```
>
> ### 事件参数 `event` 的捕捉和传递机制：
>
> 1. **事件监听器的注册**：
>    - `document.addEventListener('mousemove', callback)` 将事件监听器绑定到 `document` 上，用于监听 `mousemove` 事件。
>    - 当用户移动鼠标时，浏览器会触发 `mousemove` 事件。
> 2. **事件对象的生成**：
>    - 浏览器在触发事件时，会生成一个 `Event` 对象。对于 `mousemove` 事件，生成的对象是一个 `MouseEvent` 实例，它继承了 `Event` 的所有属性和方法，同时还包含鼠标相关的属性，比如 `clientX` 和 `clientY`。
> 3. **事件对象的传递**：
>    - 当事件触发时，浏览器会将生成的 `MouseEvent` 对象作为参数传递给监听器中定义的回调函数 `(event) => { ... }`。
> 4. **解构赋值**：
>    - 在回调函数中，通过 `const { clientX, clientY } = event;` 使用了**解构赋值**，从 `event` 对象中提取 `clientX` 和 `clientY` 属性值，代表鼠标指针相对于视口左上角的 X 和 Y 坐标。
> 5. **输出结果**：
>    - 提取到的坐标值会被插入到字符串中，并通过 `console.log` 输出到控制台。
>
> 总结： 浏览器自动生成事件对象并将其作为参数传递给事件回调函数。你只需定义回调函数的参数名称（这里是 `event`），浏览器会负责传递这个对象。
>
> MouseEvent实例中还有那些属性？
>
> `MouseEvent` 是由浏览器生成的事件对象，专门用于表示与鼠标操作相关的事件（例如 `click`、`mousemove`、`mousedown` 等）。它继承自 `UIEvent`，并进一步继承自 `Event`。`MouseEvent` 实例包含许多有用的属性，用于描述鼠标事件的详细信息。
>
> 以下是 `MouseEvent` 的主要属性：
>
> ------
>
> ### **鼠标位置信息**
>
> - **`clientX`**：鼠标指针相对于浏览器视口（窗口）左边缘的 X 坐标。
> - **`clientY`**：鼠标指针相对于浏览器视口（窗口）顶部的 Y 坐标。
> - **`screenX`**：鼠标指针相对于屏幕左边缘的 X 坐标。
> - **`screenY`**：鼠标指针相对于屏幕顶部的 Y 坐标。
> - **`pageX`**：鼠标指针相对于整个文档左边缘的 X 坐标（包括页面滚动距离）。
> - **`pageY`**：鼠标指针相对于整个文档顶部的 Y 坐标（包括页面滚动距离）。
> - **`offsetX`**：鼠标指针相对于事件目标元素左边缘的 X 坐标。
> - **`offsetY`**：鼠标指针相对于事件目标元素顶部的 Y 坐标。
>
> ------
>
> ### **鼠标按键信息**
>
> - `button`：
>   - 触发事件的鼠标按键的代码：
>     - `0`：主按钮（通常是左键）
>     - `1`：中间按钮（滚轮）
>     - `2`：次按钮（通常是右键）
> - `buttons`：
>   - 一个按位标记的数字，表示当前按下的鼠标按钮：
>     - `1`：左键
>     - `2`：右键
>     - `4`：中键 （可以组合，如同时按下左键和右键时值为 `3`）
>
> ------
>
> ### **键盘修饰键状态**
>
> 这些属性表示事件发生时是否按下了修饰键：
>
> - **`altKey`**：`true` 表示 `Alt` 键被按下。
> - **`ctrlKey`**：`true` 表示 `Ctrl` 键被按下。
> - **`metaKey`**：`true` 表示 `Meta` 键被按下（Mac 上为 `Command` 键）。
> - **`shiftKey`**：`true` 表示 `Shift` 键被按下。
>
> ------
>
> ### **拖放和相关元素**
>
> - `relatedTarget`：
>   - 对于某些事件（如 `mouseover` 和 `mouseout`），表示鼠标从哪个元素移入/移出。
> - `target`：
>   - 事件的目标元素。
> - `currentTarget`：
>   - 当前正在处理事件的元素。
>
> ------
>
> ### **其他信息**
>
> - **`movementX`**：自上一次 `mousemove` 事件以来，鼠标指针在 X 轴上的移动距离。
> - **`movementY`**：自上一次 `mousemove` 事件以来，鼠标指针在 Y 轴上的移动距离。
> - **`detail`**：事件的点击次数（适用于 `click` 和 `dblclick` 等事件）。
>
> ------
>
> ### **方法**
>
> - `getModifierState(key)`：检查指定的修饰键（如 `Alt`、`Shift`）是否被按下。
>
> ------
>
> ### 继承自 `UIEvent` 和 `Event` 的属性
>
> - **`type`**：事件类型（如 `"click"`、`"mousemove"`）。
> - **`target`**：事件触发的目标元素。
> - **`bubbles`**：`true` 表示事件会冒泡。
> - **`cancelable`**：`true` 表示事件可以被取消。
> - **`defaultPrevented`**：`true` 表示默认操作已被阻止。
> - **`timeStamp`**：事件触发时的时间戳。
>
> ------
>
> ### 示例
>
> ```javascript
> document.addEventListener('mousemove', (event) => {
>   console.log('clientX:', event.clientX);
>   console.log('clientY:', event.clientY);
>   console.log('screenX:', event.screenX);
>   console.log('button:', event.button); 
>   console.log('altKey pressed:', event.altKey);
> });
> ```
>
> 这些属性可以帮助开发者获取鼠标的位置信息、按键状态和修饰键等详细信息，以便实现复杂的鼠标交互功能。

##### **Q.7:什么是解构赋值？**

> 在 `const { clientX } = event;` 和 `const clientX = event.clientX;` 中，**`clientX`** 最终的效果是等价的，它们都会从 `event` 对象中提取 `clientX` 的值并赋值给一个同名变量。
>
> 但它们的语法和解构方式不同，具体区别如下：
>
> ------
>
> ### **解构赋值 (`const { clientX } = event;`)**
>
> 这是 **ES6 解构赋值** 的语法，用于从对象中提取属性并赋值给同名变量。
>
> ```javascript
> const { clientX } = event;
> ```
>
> 等价于：
>
> ```javascript
> const clientX = event.clientX;
> ```
>
> 优点：
>
> - 可以同时提取多个属性：
>
>   ```javascript
>   const { clientX, clientY } = event;
>   ```
>
>   上述写法相当于：
>
>   ```javascript
>   const clientX = event.clientX;
>   const clientY = event.clientY;
>   ```
>
> - 语法更加简洁，适合处理多个属性时使用。
>
> ------
>
> ### **普通赋值 (`const clientX = event.clientX;`)**
>
> 这是更传统的方式，逐个访问对象属性并赋值。
>
> ```javascript
> const clientX = event.clientX;
> ```
>
> 优点：
>
> - 更直观，适合只提取单个属性时。
>
> ------
>
> ### **总结**
>
> 两种写法最终效果是**等价**的，区别在于语法形式和适用场景：
>
> 1. 如果只需要提取单个属性，使用 `const clientX = event.clientX;` 和 `const { clientX } = event;` 都可以。
> 2. 如果需要提取多个属性，解构赋值更简洁且可读性更好。
>
> 例如：
>
> ```javascript
> // 解构赋值
> const { clientX, clientY } = event;
> // 传统方式
> const clientX = event.clientX;
> const clientY = event.clientY;
> ```

这里遇到了新的问题，最初设置<div>依靠的是百分比作为位置信息，在js操作中利用的是px，导致操作繁琐。

现在尝试把之前的代码进行一定的修改，在一番折腾后写出了以下代码：

```JS
    let offsetX = 0;
    let offsetY = 0;
    let nicoDivX =0;
    let nicoDivY =0;
    let ifDragging = false;
    //充当一个布尔变量，用于判断是否在抓取移动状态,let为局部变量
    nicoNoteDiv.addEventListener("mousedown",(e) => {//"mousedown"即监测鼠标点下的事件。
        ifDragging = true;
        nicoNoteDiv.style.cursor = "move";
        offsetX = e.clientX;
        offsetY = e.clientY;
        //记录初始鼠标坐标(相对于左上角)
        nicoDivY = parseInt(nicoNoteDiv.style.top);
        nicoDivX = parseInt(nicoNoteDiv.style.right);
        //获取div的位置parseInt（）会将字符串转化为数字（忽略最后的非数字部分）
        e.preventDefault();
        //用来禁止鼠标拖拽时选中的功能
        nicoNoteDiv.addEventListener('mousemove',(e)=>{if (ifDragging){nicoDragging(e)}});
        //通过检测是否拖拽来启用拖拽函数
    });
    function nicoDragging(e) {//定义一个Dragging函数 语法：function 函数名(参数) {}
        const { clientX, clientY } = e;
        //获取当前鼠标坐标
        nicoNoteDiv.style.top = `${nicoDivY+clientY-offsetY}px`;
        //${}表示在字符串中插入函数或变量，但要确保使用反引号`Code`
        nicoNoteDiv.addEventListener("mouseup",() =>{ifDragging = false;});
        //松开鼠标，停止拖拽
    };
```

但是事情并没有那么简单，在松开鼠标后这个玩意还在动，原因如下：

>  JavaScript 中，监听器（事件监听器）只要没有被明确移除或停止，就会一直监听事件。
>
> 当你使用诸如 `addEventListener` 方法在 DOM 元素上绑定一个事件监听器时，这个监听器会一直处于活动状态，直到满足以下条件之一：
>
> 1. **手动移除监听器**：
>    可以使用 `removeEventListener` 方法来移除监听器。例如：
>
>    ```javascript
>    const button = document.getElementById('myButton');
>    function handleClick(event) {
>        console.log('Button clicked!');
>    }
>    
>    // 添加监听器
>    button.addEventListener('click', handleClick);
>    
>    // 移除监听器
>    button.removeEventListener('click', handleClick);
>    ```
>
> 2. **元素被移除**：
>    如果绑定了监听器的 DOM 元素被从 DOM 中移除，监听器也会随之停止。
>
> 3. **一次性监听器**：
>    如果在添加监听器时指定了 `{ once: true }`，监听器会在首次触发后自动移除。例如：
>
>    ```javascript
>    button.addEventListener('click', handleClick, { once: true });
>    ```
>
> ### 父监听器与子监听器的关系
>
> 如果你指的是在父元素上添加的事件监听器（比如通过事件冒泡机制监听子元素的事件），这种父监听器也会一直监听，除非明确移除。事件冒泡意味着子元素触发的事件会逐层向上传递到父元素，因此父监听器会接收到事件。比如：
>
> ```javascript
> const parent = document.getElementById('parent');
> 
> // 父元素监听器
> parent.addEventListener('click', (event) => {
>     console.log('Parent clicked!', event.target);
> });
> ```
>
> 无论是直接点击父元素，还是点击子元素，父元素的监听器都会被触发，除非：
>
> - 你使用 `stopPropagation()` 来阻止冒泡；
> - 或者通过 `removeEventListener` 手动移除父监听器。
>
> ### 总结
>
> - 监听器会持续监听事件，直到手动移除或绑定的 DOM 元素被移除。
> - 如果没有停止或移除，父监听器会一直监听其范围内的事件冒泡。

也就是说，由于`mousemove`在`mousedown`内导致`mousedmove`一直没法停止。把:

```JS
nicoNoteDiv.addEventListener('mousemove',(e)=>{if (ifDragging){nicoDragging(e)}});
 nicoNoteDiv.addEventListener("mouseup",() =>{ifDragging = false;});
```

插在外面就行了。

最终成品：

```JS
        let offsetX = 0;
        let offsetY = 0;
        let nicoDivX =0;
        let nicoDivY =0;
        let ifDragging = false;
        //充当一个布尔变量，用于判断是否在抓取移动状态,let为局部变量
        nicoNoteDiv.addEventListener("mousedown",(e) => {//"mousedown"即监测鼠标点下的事件。
            ifDragging = true;
            offsetX = e.clientX;
            offsetY = e.clientY;
            //记录初始鼠标坐标(相对于左上角)
            nicoDivY = parseInt(nicoNoteDiv.style.top);
            nicoDivX = parseInt(nicoNoteDiv.style.right);
            //获取div的位置parseInt（）会将字符串转化为数字（忽略最后的非数字部分）
            e.preventDefault();
            //用来禁止鼠标拖拽时选中的功能
        });
        nicoNoteDiv.addEventListener('mousemove',(e)=>{
            if(ifDragging){
                const { clientX, clientY } = e;
                //获取当前鼠标坐标
                nicoNoteDiv.style.top = `${nicoDivY+clientY-offsetY}px`;
                nicoNoteDiv.style.right = `${nicoDivX-clientX+offsetX}px`;
                //${}表示在字符串中插入函数或变量，但要确保使用反引号`Code `
            }
         });
        nicoNoteDiv.addEventListener("mouseup",() =>{ifDragging = false;});
        //松开鼠标，停止拖拽
```

考虑到这个玩意可以应用到之前那个图标上，我们把它封装成一个函数。

由于光标太快会划出`element`，有时候`mousedown`事件会停止监听，改变策略把`mousemove`和`mouseup`监听对象改为`document`，即：` document.addEventListener()`。

这里有个新问题：

##### **Q.8如何在拖拽的同时不触发点击？**

> ### 方法一：通过 `mousemove` 判断是否发生拖拽
>
> 可以在 `mousedown` 和 `mousemove` 中记录鼠标的移动距离，并在 `mouseup` 时判断是否是一次有效的拖拽操作。如果移动的距离超过一定阈值，就认为是拖拽而非点击。
>
> ```javascript
> let isDragging = false;
> 
> const element = document.querySelector("#draggable");
> 
> element.addEventListener("mousedown", (e) => {
>     isDragging = false; // 重置拖拽状态
>     const startX = e.clientX;
>     const startY = e.clientY;
> 
>     const onMouseMove = (e) => {
>         if (Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5) {
>             isDragging = true;
>         }
>     };
> 
>     const onMouseUp = () => {
>         document.removeEventListener("mousemove", onMouseMove);
>         document.removeEventListener("mouseup", onMouseUp);
>     };
> 
>     document.addEventListener("mousemove", onMouseMove);
>     document.addEventListener("mouseup", onMouseUp);
> });
> 
> element.addEventListener("click", (e) => {
>     if (isDragging) {
>         e.preventDefault(); // 如果是拖拽，不触发点击
>     }
> });
> ```
>
> ### 方法二：使用 `drag` 和 `dragstart` 事件
>
> 如果使用 HTML5 的拖放 API，可以利用 `drag` 和 `dragstart` 来区分拖拽和点击。
>
> ```javascript
> let isDragging = false;
> 
> const element = document.querySelector("#draggable");
> 
> element.addEventListener("dragstart", () => {
>     isDragging = true; // 标记为拖拽
> });
> 
> element.addEventListener("click", (e) => {
>     if (isDragging) {
>         e.preventDefault(); // 阻止点击事件
>         isDragging = false; // 重置状态
>     }
> });
> ```
>
> ### 方法三：直接在 `click` 中判断拖拽状态
>
> 如果你的拖拽实现中没有其他复杂的状态，也可以简单地在 `click` 事件中检查。
>
> ```javascript
> let isDragging = false;
> 
> element.addEventListener("mousedown", () => {
>     isDragging = false;
> });
> 
> element.addEventListener("mousemove", () => {
>     isDragging = true; // 如果发生移动，标记为拖拽
> });
> 
> element.addEventListener("mouseup", () => {
>     setTimeout(() => (isDragging = false), 0); // 延迟重置状态
> });
> 
> element.addEventListener("click", (e) => {
>     if (isDragging) {
>         e.preventDefault();
>     }
> });
> ```
>
> ### 方法四：CSS `pointer-events` 阻止点击
>
> 如果拖拽操作是通过 CSS 结合 JavaScript 实现，可以在拖拽时临时禁用 `pointer-events`。
>
> ```javascript
> const element = document.querySelector("#draggable");
> 
> element.addEventListener("mousedown", () => {
>     element.style.pointerEvents = "none"; // 禁止点击
> });
> 
> element.addEventListener("mouseup", () => {
>     setTimeout(() => {
>         element.style.pointerEvents = "auto"; // 恢复点击
>     }, 0);
> });
> ```
>
> ### 总结
>
> 最推荐的方法是 **方法一**，结合鼠标的移动距离判断是否是拖拽，因为它适用于大多数拖拽实现场景，且与 HTML5 拖放 API 或 CSS 的依赖性较低。

这里采用方法四，而 mouseup 的监听对象一定为 document 才有效，最后将right改为更易操作的的left，封装后的函数如下：

```js
    function letWeDrag(dragDiv){
        let offsetX = 0;
        let offsetY = 0;
        let nicoDivX =0;
        let nicoDivY =0;
        let ifDragging = false;
        //充当一个布尔变量，用于判断是否在抓取移动状态,let为局部变量
        dragDiv.addEventListener("mousedown",(e) => {//"mousedown"即监测鼠标点下的事件。
            ifDragging = true;
            offsetX = e.clientX;
            offsetY = e.clientY;
            //记录初始鼠标坐标(相对于左上角)
            nicoDivY = parseInt(dragDiv.style.top);
            nicoDivX = parseInt(dragDiv.style.left);
            //获取div的位置parseInt（）会将字符串转化为数字（忽略最后的非数字部分）
            e.preventDefault();
            //用来禁止鼠标拖拽时选中的功能
        });
        document.addEventListener('mousemove',(e)=>{
            if(ifDragging){
                const { clientX, clientY } = e;
                //获取当前鼠标坐标
                dragDiv.style.top = `${nicoDivY+clientY-offsetY}px`;
                dragDiv.style.left = `${nicoDivX+clientX-offsetX}px`;
                //${}表示在字符串中插入函数或变量，但要确保使用反引号`Code`
                dragDiv.style.pointerEvents = "none";
                //禁止单击，防止拖拽同时点击。
            }
        });
        document.addEventListener("mouseup",() =>{
            ifDragging = false;
            dragDiv.style.pointerEvents = "auto"; // 恢复点击
        });
        //松开鼠标，停止拖拽
    }
```

由于将right换用left，为了使图标继续在右侧，我们应该获取屏幕的宽度。

##### Q.7如何获取屏幕的宽度？

在 JavaScript 中，可以使用以下方法获取屏幕的 **像素信息**：

------

> ### **1. 获取屏幕的宽度和高度（`window.screen`）**
>
> 通过 `window.screen` 对象，可以获取屏幕的物理分辨率：
>
> ```javascript
> console.log("屏幕宽度：" + window.screen.width + "px");
> console.log("屏幕高度：" + window.screen.height + "px");
> ```
>
> - `window.screen.width`：屏幕的宽度（像素）。
> - `window.screen.height`：屏幕的高度（像素）。
>
> ------
>
> ### **2. 获取可用工作区域的尺寸**
>
> `window.screen.availWidth` 和 `window.screen.availHeight` 用于获取屏幕除去任务栏或工具栏后的可用尺寸：
>
> ```javascript
> javascript复制代码console.log("可用宽度：" + window.screen.availWidth + "px");
> console.log("可用高度：" + window.screen.availHeight + "px");
> ```
>
> ------
>
> ### **3. 获取浏览器窗口的尺寸**
>
> 通过 `window.innerWidth` 和 `window.innerHeight` 可以获取浏览器窗口的内容区域大小（不包含工具栏或边框）：
>
> ```javascript
> javascript复制代码console.log("窗口宽度：" + window.innerWidth + "px");
> console.log("窗口高度：" + window.innerHeight + "px");
> ```
>
> ------
>
> ### **4. 获取设备像素比（`devicePixelRatio`）**
>
> `window.devicePixelRatio` 返回设备像素比（DPR），表示物理像素与 CSS 像素的比值：
>
> ```javascript
> console.log("设备像素比：" + window.devicePixelRatio);
> ```
>
> 例如：
>
> - 如果 `devicePixelRatio = 2`，表示 1 个 CSS 像素对应 2 个物理像素。
> - 通常高分辨率设备（如 Retina 屏幕）会有较高的 DPR 值。
>
> ------
>
> ### **5. 获取页面滚动的像素位置**
>
> 通过 `window.scrollX` 和 `window.scrollY` 可以获取页面的水平和垂直滚动位置：
>
> ```javascript
> console.log("水平滚动位置：" + window.scrollX + "px");
> console.log("垂直滚动位置：" + window.scrollY + "px");
> ```
>
> ------
>
> ### **6. 获取元素的大小和位置**
>
> 如果要获取某个 HTML 元素的宽度和高度，可以使用 `getBoundingClientRect()`：
>
> ```javascript
> const element = document.querySelector("#myElement");
> const rect = element.getBoundingClientRect();
> console.log(`元素宽度：${rect.width}px, 高度：${rect.height}px`);
> console.log(`元素位置：左=${rect.left}px, 上=${rect.top}px`);
> ```
>
> ------
>
> ### **总结**
>
> - 屏幕尺寸：`window.screen.width` 和 `window.screen.height`
> - 可用区域：`window.screen.availWidth` 和 `window.screen.availHeight`
> - 浏览器窗口：`window.innerWidth` 和 `window.innerHeight`
> - DPR：`window.devicePixelRatio`
> - 滚动位置：`window.scrollX` 和 `window.scrollY`

这里我们用到`window.innerWidth`就可以了。

#### ②拖拽调节大小

只需要在CSS中添加：

```CSS
resize: both;/*允许元素在x、y两个方向上调整大小*/
overflow: auto;/*显示滚动条*/
```

就可以实现简单的调整大小,参考[CSS3中的resize属性—用于控制元素是否可以被用户调整大小_css resize-CSDN博客](https://blog.csdn.net/qq_44327851/article/details/135040288#:~:text=使用 resize%3A both%3B,来指定同时允许在水平和垂直方向上调整大小， overflow%3A auto%3B 用于显示滚动条来容纳)。

**注意的是，能正常调整的条件是：CSS样式中，元素的位置描述使用 top 与 left。**

#### ③组合起来！

由于这两者判定位置重合，因此我们应该使用一定的嵌套。

这时我们就要对 UI 进行一定的规划：也就是流出上方一条允许拖拽，其余部分无法拖拽。

让外层元素调节大小，内层元素负责拖动，这样一个东西就做好了！



