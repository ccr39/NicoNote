# 从零开始编写一个浏览器笔记脚本

> 故事的开始：
>
> 在浏览器上学习时时常要记笔记。
>
> 在预览网络上已有的各类插件后本人发现，这类插件往往已经长时间失去维护，或需要付费使用。
>
> 为什么不自己制作一个有类似功能的脚本呢？
>
> 在几乎没有任何理论知识的前提下本人决定实施这个构想。

## 一、开始前的准备

### 希望实现的功能

基本功能：

- [ ] 能够在网页上编写笔记，并保存在本地。可以在网页后显示对应笔记。
- [ ] 能够使用 Markdown 语法并实现实时渲染 $\LaTeX$ 。
- [ ] 能够导出与导入 Markdown 笔记。
- [ ] 能够调整笔记框的大小。

进阶功能：

- [ ] 美化笔记框背景。
- [ ] 可以根据网页中的某条内容链接到笔记的某一部分。
- [ ] 可以根据视频的进度链接到笔记。
- [ ] （待思考）

### 实现方案

1、使用 **Tampermonkey** 编写基本主体脚本。这需要学习一部分网页前端知识。

2、使用开源的纯前端 Markdown 文字编辑器。

3、利用 **Git** 进行版本控制与脚本的发布。

## 二、让我们开始吧

尝试了解 **Tampermonkey**，发现官方文档没有进行汉化，因此翻阅了中文的[油猴开发指南](https://learn.scriptcat.org/简介/)。

### 1、对头部元数据的理解

| 元数据                                           | 值                                                           |
| ------------------------------------------------ | ------------------------------------------------------------ |
| `@name( :zh-CN :zh-TW :en )`                     | 脚本的名字(简中，繁中，英文)。                               |
| `@namespace`                                     | 一般为一个 URL 或自定义的内容，用于脚本管理器在`@name`相同的情况下识别唯一的脚本 |
| `@version`                                       | 脚本的版本。                                                 |
| `@author `                                       | 脚本作者。                                                   |
| `@description( :zh-CN :zh-YW :en )`              | 脚本的描述(简中，繁中，英文)。                               |
| `@include`                                       | 脚本应该运行的页面， 可以使用**通配符**， 允许多个标签。     |
| `@match`                                         | 与@include相似，区别是不可以用通配符，更精确因此更为常用，允许多个标签。 |
| `@exclude`                                       | 排除URL，即使它们包含在@include或@match中 ，允许多个标签。   |
| `@icon  @iconURL` `@defaulticon`                 | 脚本的图标的 URL，会在脚本管理列表上显示。                   |
| `@icon64` `@icon64URL`                           | 64*64 的图标文件的 URL ，可能会在选项中缩放。                |
| `@updateURL`                                     | 更新脚本的地址，该URL应该指向一个脚本文件，只需要定期更新该文件即可实现对脚本的更新。注意：只有存在@version标签才会去更新。 |
| `@downloadURL`                                   | 定义脚本的下载地址（一般指的是手动安装脚本时的文件）通常和 `@updateURL` 指向同一文件较常见。 |
| `@license`                                       | 用于声明脚本的**许可证类型**。许可证定义了其他人如何使用、修改和分发你的脚本。 |
| `@grant`                                         | 声明脚本会用到的**特殊权限或功能**。它决定了脚本是否可以使用某些特定的 API，或者是否可以访问用户脚本管理器提供的功能。可以存在多条 |
| `@require`                                       | 指向一个脚本文件，会在本脚本运行前加载并执行                 |
| `@run-at`                                        | 定义脚本被注入的时间，与其他脚本处理相反，`@run-at` 定义了脚本要运行的第一可能时间。这意味着，使用`@require`标记的脚本可能会在文档已加载后执行，因为获取所需脚本花费了很长时间。 |
| `@supportURL`                                    | 插件个人支持的地址，用于提交 issue 。                        |
| `@homepage` `@homepageURL` `@website`  `@source` | 在“选项”页上用于从脚本名链接到给定页的作者主页。请注意，如果@namespace标记以“http://”开头，则其内容也将用于此操作。 |
| `@connect`                                       | 用于声明可以与那些外部的域名进行跨域通信，未声明的域名在脚本中将被禁止访问，允许多个标签。可以使用`@connect *`允许所有域名（不推荐，可能带来安全风险）。 |

**部分元数据的常用值**

①关于`@license`常见的许可证类型：

| **许可证**      | **作用/特点**                                                |
| --------------- | ------------------------------------------------------------ |
| **MIT**         | 允许几乎任何使用，包括修改、分发和商业用途，只需保留原作者声明。 |
| **GNU GPL-3.0** | 允许修改和分发，但要求开源修改后的版本，适合需要保持自由传播的软件。 |
| **Apache-2.0**  | 类似于 MIT，但要求保留通知文件，并保护专利权。               |
| **CC-BY-4.0**   | 允许分享和修改，只需署名原作者，常用于非软件内容。           |
| **Unlicense**   | 放弃所有版权，允许任何用途。                                 |
| **WTFPL**       | `Do What The Fuck You Want To Public License`中文译：你他妈的想干嘛就干嘛公共许可证。是一种不太常用的、极度放任的自由软件许可证。它的条款基本等同于贡献到公有领域。 |
| **Custom**      | 自定义声明，允许作者明确指定特殊的版权声明，例如：`仅供个人使用，禁止修改传播`。 |

②`@grant` 的常用值

| **@grant 值**              | **描述**                                                   |
| -------------------------- | ---------------------------------------------------------- |
| `none`                     | 不授予任何特殊权限，脚本与页面共享相同的全局作用域。       |
| `GM_addStyle`              | 向页面动态添加 CSS 样式。                                  |
| `GM_getValue`              | 从脚本的本地存储中获取数据。                               |
| `GM_setValue`              | 将数据存储到脚本的本地存储中。                             |
| `GM_deleteValue`           | 删除脚本本地存储中的数据。                                 |
| `GM_listValues`            | 获取所有存储值的键名列表。                                 |
| `GM_xmlhttpRequest`        | 发起跨域的 HTTP 请求（比原生的 `XMLHttpRequest` 更强大）。 |
| `GM_download`              | 下载文件到本地。                                           |
| `GM_notification`          | 在桌面弹出通知。                                           |
| `GM_openInTab`             | 在新标签页中打开一个链接。                                 |
| `GM_registerMenuCommand`   | 向用户脚本菜单添加自定义选项。                             |
| `GM_unregisterMenuCommand` | 删除自定义的菜单选项。                                     |
| `GM_setClipboard`          | 将内容复制到系统剪贴板。                                   |
| `GM_info`                  | 提供有关用户脚本的信息（只读）。                           |

③`@run-at`的常用值

| **@run-at 值**   | **描述**                                                     |
| ---------------- | ------------------------------------------------------------ |
| `document-start` | 脚本会被尽可能快地注入                                       |
| `document-body`  | 当body元素存在是被注入                                       |
| `document-end`   | 当 DOMContentLoaded 事件被触发时或者之后注入                 |
| `document-idle`  | 当 DOMContentLoaded 事件被触发后被注入 如果没有@run-at标签也是在此时注入 |

### 2、目前产生的问题（ChatGPT 解答）

**Q.1：@downloadURL和@updateURL的区别**

> 在编写油猴（Tampermonkey 或 Greasemonkey）脚本时，`@include` 和 `@match` 是用来定义脚本作用范围的元数据注释。它们的作用类似，但有一些关键区别：
>
> ------
>
> ### **@include**
>
> - **用途**：匹配指定的 URL 模式，让脚本在符合模式的页面上运行。
>
> - **语法**：支持通配符（*），简单易用。
>
>   - `*`：匹配任意字符。
>
>   - 示例：
>
>     ```javascript
>     // 脚本会在所有以 "https://example.com/" 开头的页面上运行
>     @include https://example.com/*
>     ```
>
> - 匹配示例：
>
>   - ```
>     https://example.com/*
>     ```
>
>      可以匹配：
>
>     - `https://example.com/page1`
>     - `https://example.com/page2`
>
>   - 通配符 *也可以放在中间或末尾，如：
>
>     - `https://*.example.com/*` 匹配所有子域名。
>
> ------
>
> ### **@match**
>
> - **用途**：更严格地匹配 URL 模式，符合 URL 模式规范。
>
> - **语法**：不支持简单的 * 通配符定义所有，而是更精确的匹配规则。
>
>   - 但可以使用通配符 `*` 匹配子域名或协议。
>
>   - 示例：
>
>     ```
>     javascript复制代码// 脚本会在 https://example.com 的所有页面运行
>     @match https://example.com/*
>     ```
>
> - 匹配示例：
>
>   - ```
>     https://*.example.com/*
>     ```
>
>      可以匹配：
>
>     - `https://sub.example.com/page`
>     - `https://another.example.com/page`
>
>   - 但不会匹配：
>
>     - `http://example.com`（因为协议不同）。
>
> ------
>
> ### **关键区别**
>
> | 特性         | `@include`             | `@match`                                |
> | ------------ | ---------------------- | --------------------------------------- |
> | **灵活性**   | 支持简单通配符，较宽松 | 严格匹配 URL，符合标准规范              |
> | **安全性**   | 容易出现误匹配         | 更严格，减少误匹配的风险                |
> | **协议要求** | 可以省略协议           | 必须指定协议（`http://` 或 `https://`） |
> | **兼容性**   | 旧版脚本可能使用更多   | 推荐使用，符合现代浏览器扩展规范        |
>
> ------
>
> ### **使用建议**
>
> 1. 如果需要快速定义作用域，且 URL 规则较简单，可以使用 `@include`。
> 2. 如果需要更安全、更准确的匹配，建议使用 `@match`，特别是在现代浏览器扩展环境下。
>
> > 现代浏览器和 Tampermonkey 都更推荐使用 `@match`，因为它的匹配规则符合浏览器扩展的标准。
>
> ### 个人总结
>
> 两者用来将脚本应用到所有的页面，应分别如下写：
>
> `@match        *://*/*`
>
> `@include	   *`

**Q.2：什么是 DOMContentLoaded 事件？**

> `DOMContentLoaded` 是一个常见的 JavaScript 事件，用于监听 HTML 文档的加载状态。当浏览器解析完所有的 HTML 并构建完成 DOM 树时，就会触发 `DOMContentLoaded` 事件，而无需等待其他资源（如图片、样式表和脚本文件）的加载完成。
>
> ------
>
> ### **特点**
>
> 1. **触发时机**：当 HTML 文档被完全加载和解析完成时（即 DOM 树构建完成）。
> 2. **不等待其他资源**：与 `window.onload` 不同，`DOMContentLoaded` 不需要等待图片、样式表、iframe 等资源加载完成后才触发。
> 3. **适用于操作 DOM**：在该事件触发时，DOM 已经可用，因此适合初始化页面内容或操作 DOM 元素。
>
> ------
>
> ### **用法**
>
> 监听 `DOMContentLoaded` 的方法有以下几种：
>
> #### **1. 使用 `addEventListener`**
>
> ```javascript
> document.addEventListener("DOMContentLoaded", function() {
>     console.log("DOM 已完全加载并解析");
>     // 可以安全地操作 DOM 元素
>     document.body.style.backgroundColor = "lightblue";
> });
> ```
>
> #### **2. 使用旧的 `onreadystatechange`**
>
> 早期浏览器中，可以通过 `readyState` 属性判断文档是否加载完成：
>
> ```javascript
> document.onreadystatechange = function() {
>     if (document.readyState === "interactive") {
>         console.log("DOM 已完全加载并解析");
>     }
> };
> ```
>
> #### **3. 直接在脚本末尾执行**
>
> 如果你的脚本放在文档的底部（`</body>`标签之前），可以不显式监听 `DOMContentLoaded`，因为此时 DOM 已经解析完成：
>
> ```html
> <!DOCTYPE html>
> <html>
> <head>
>     <title>Example</title>
> </head>
> <body>
>     <h1>Hello, World!</h1>
>     <script>
>         console.log(document.querySelector("h1").textContent); // "Hello, World!"
>     </script>
> </body>
> </html>
> ```
>
> ------
>
> ### **`DOMContentLoaded` 和 `window.onload` 的区别**
>
> | 特性                 | `DOMContentLoaded`                    | `window.onload`                            |
> | -------------------- | ------------------------------------- | ------------------------------------------ |
> | **触发时机**         | DOM 树构建完成（HTML 已加载并解析）。 | 页面所有资源（包括图片、样式等）加载完成。 |
> | **是否等待外部资源** | 不等待外部资源加载完成。              | 等待所有外部资源加载完成。                 |
> | **使用场景**         | 初始化 DOM 操作或页面功能。           | 确保所有资源可用（如图片尺寸）。           |
>
> ------
>
> ### **示例：两者对比**
>
> ```javascript
> document.addEventListener("DOMContentLoaded", function() {
>     console.log("DOM 已加载完成，但图片可能还在加载中");
> });
> 
> window.addEventListener("load", function() {
>     console.log("页面所有资源加载完成，包括图片和样式");
> });
> ```
>
> ------
>
> ### **浏览器支持**
>
> `DOMContentLoaded` 是一个标准事件，现代浏览器（包括 IE9+）都完全支持。
>
> ------
>
> ### **使用建议**
>
> - **推荐场景**：如果你的脚本只需要操作 DOM 元素（如添加事件监听器或修改内容），优先使用 `DOMContentLoaded`，因为它比 `window.onload` 更早触发。
> - **性能优化**：通过监听 `DOMContentLoaded`，可以更快地响应用户交互，而无需等待所有资源加载完成。

**Q.3：什么是DOM树？**

**DOM 树**（Document Object Model Tree）是浏览器在加载和解析 HTML 文档时，根据 HTML 的层级结构生成的一种**树形数据结构**。它表示了文档的结构以及每个节点之间的关系，使得 JavaScript 可以通过 DOM API 操作页面内容和结构。

------

### **DOM 树的组成**

> DOM 树由以下几种节点组成，每个节点代表 HTML 文档的一部分：
>
> 1. **文档节点（Document Node）**：
>    - 表示整个 HTML 文档的根节点。
>    - 通过 JavaScript 的 `document` 对象访问。
> 2. **元素节点（Element Nodes）**：
>    - 表示 HTML 的元素标签，例如 `<div>`、`<p>`。
>    - 元素节点可以嵌套形成层级结构。
> 3. **属性节点（Attribute Nodes）**：
>    - 表示 HTML 元素的属性，例如 `id="example"`。
>    - 属性是元素节点的一部分，但在 DOM 树中不是子节点，而是直接附属于对应的元素节点。
> 4. **文本节点（Text Nodes）**：
>    - 表示元素或属性中的文本内容。
>    - 文本节点始终是叶节点，没有子节点。
> 5. **注释节点（Comment Nodes）**：
>    - 表示 HTML 文档中的注释内容。
>
> ------
>
> ### **DOM 树的结构**
>
> 以以下 HTML 代码为例：
>
> ```html
> <!DOCTYPE html>
> <html>
>   <head>
>     <title>Example</title>
>   </head>
>   <body>
>     <h1 id="header">Hello, World!</h1>
>     <p>Welcome to DOM.</p>
>   </body>
> </html>
> ```
>
> 对应的 DOM 树结构如下：
>
> ```bash
> Document
>  └── html
>       ├── head
>       │     └── title
>       │           └── "Example"
>       └── body
>             ├── h1
>             │     ├── Attribute: id="header"
>             │     └── "Hello, World!"
>             └── p
>                   └── "Welcome to DOM."
> ```
>
> ------
>
> ### **DOM 树的特点**
>
> 1. **层级关系**：
>    - HTML 文档的嵌套结构会在 DOM 树中反映为父子关系。
>    - 每个 HTML 元素是一个节点，嵌套关系形成了树状层级。
> 2. **节点类型**：
>    - 可以通过 `nodeType` 属性查看节点类型，例如：
>      - `1`：元素节点
>      - `3`：文本节点
>      - `8`：注释节点
> 3. **可遍历**：
>    - DOM 树中的节点可以通过 JavaScript 遍历，例如 `parentNode`、`childNodes`、`nextSibling` 等。
>
> ------
>
> ### **常见操作**
>
> 1. **获取节点**：
>
>    ```javascript
>    const header = document.getElementById("header"); // 获取 h1 元素
>    const paragraphs = document.getElementsByTagName("p"); // 获取所有 <p> 元素
>    ```
>
> 2. **修改节点内容**：
>
>    ```javascript
>    const header = document.getElementById("header");
>    header.textContent = "Hello, DOM!";
>    ```
>
> 3. **添加新节点**：
>
>    ```javascript
>    const newDiv = document.createElement("div");
>    newDiv.textContent = "This is a new div.";
>    document.body.appendChild(newDiv);
>    ```
>
> 4. **删除节点**：
>
>    ```javascript
>    const header = document.getElementById("header");
>    header.remove();
>    ```
>
> ------
>
> ### **DOM 树的作用**
>
> 1. **页面动态交互**：通过操作 DOM 树，可以动态修改页面的结构和内容。
> 2. **事件绑定**：JavaScript 事件处理器通过 DOM 树关联 HTML 元素。
> 3. **样式动态调整**：通过修改 DOM 节点的样式属性实现动态效果。
>
> ------
>
> ### **总结**
>
> DOM 树是 HTML 文档在浏览器中的表示形式，它将 HTML 结构化为可以用 JavaScript 操作的对象模型。熟练掌握 DOM 树和相关操作是前端开发的基础。

2024/12/8

--------

### 3、Hello World

在头部元数据下方标注了书写代码的地方。

```javascript
(function() {
    'use strict';

// Your code here...

})();
```

根据文档描述，脚本的书写应该使用`JavaScript`。

利用`alert()`弹出一个对话框，并输出 HelloWorld，并使用`@include *`将其应用到所有页面。

```javascript
// ==UserScript==
//@name    a_simple_test
//@include *
// ==/UserScript==
(function() {
    'use strict';
	alert('HelloWorld')
// Your code here...

})();
```

这样，在打开任意网站后，都会弹出一个 HelloWorld 的对话框。

### 4、熟悉  JavaScript  的语法

在[JavaScript 用法 | 菜鸟教程](https://www.runoob.com/js/js-howto.html)中了解JS的基本用法。

在此出现的问题：

**Q.4：之前 HelloWorld 脚本中的`alert('HelloWorld')`末尾没有分号，这种写法是否合法？**

> 是合法的！在 JavaScript 中，分号（`;`）是**可选的**，因为 JavaScript 有一个**自动分号插入（Automatic Semicolon Insertion, ASI）**的机制。在大多数情况下，即使你省略了分号，JavaScript 引擎也会根据上下文自动插入。
>
> ------
>
> ### **解释代码中的 `alert('HelloWorld')`**
>
> 在以下代码中：
>
> ```javascript
> alert('HelloWorld')
> ```
>
> 即使没有写分号，JavaScript 引擎仍然能正确解析，因为：
>
> 1. `alert('HelloWorld')` 是一个独立的语句。
>
> 2. ASI 机制会在行末自动插入分号，等效于：
>
>    ```javascript
>    alert('HelloWorld');
>    ```
>
> 因此，这种省略分号的写法是合法的。
>
> ------
>
> ### **什么时候分号是必要的？**
>
> 尽管 ASI 机制可以避免大部分语法错误，但在某些特定情况下，**省略分号可能导致意外行为**。例如：
>
> #### 情况 1：行首是 `[` 或 `(` 的表达式
>
> ```javascript
> let a = 5
> [1, 2, 3].forEach(x => console.log(x))
> ```
>
> 在这种情况下，JavaScript 会将 `[1, 2, 3]` 视为数组访问器，而不是独立的数组字面量。
>
> 解决方法：
>
> ```javascript
> let a = 5;
> [1, 2, 3].forEach(x => console.log(x));
> ```
>
> #### 情况 2：返回值与表达式在不同行
>
> ```javascript
> function test() {
>     return
>     {
>         value: 42
>     }
> }
> console.log(test()) // undefined
> ```
>
> 在这种情况下，`return` 语句后自动插入了分号，因此实际返回的是 `undefined`。
>
> 解决方法：
>
> ```javascript
> function test() {
>     return {
>         value: 42
>     };
> }
> ```
>
> ------
>
> ### **建议**
>
> 1. **始终使用分号**：虽然 JavaScript 的 ASI 机制可以省略分号，但为了代码的可读性和避免潜在的错误，建议显式添加分号。
> 2. **遵循团队规范**：如果项目使用了某种代码风格（如 Airbnb 或 Standard），遵循其规范（例如 Standard JS 就不使用分号）。
> 3. **工具辅助**：使用代码检查工具（如 ESLint）和格式化工具（如 Prettier）来统一代码风格。
>
> ------
>
> ### **结论**
>
> 在你的脚本中，省略 `alert('HelloWorld')` 的分号是合法的，且能正确运行。不过，养成显式添加分号的习惯会更安全、更规范。

### 5、（番外）为插件创作一个图标

使用 ChatGPT 绘制一个笔记本的图标，将其转换为64*64大小。

使用 [SVG 在线编辑器 | 菜鸟工具](https://www.jyshare.com/more/svgeditor/) 将其转化为矢量图形，并使其可以用代码表示出来。

发现 ChatGPT 绘制的图形不是纯色图形，会导致代码过长，故放弃使用 ChatGPT 绘制的图形，转而使用网络上公开的资源。

再次使用 SVG 工具将其稍加修改得到以下图形。

<svg xmlns="http://www.w3.org/2000/svg" width="512" height="512" enable-background="new 0 0 512 512">
 <g>
  <title>Layer 1</title>
  <rect id="svg_5" height="571.99998" width="596.99998" y="-40.33333" x="-61.00001" stroke="#000" fill="#007fff"/>
  <g stroke="null" id="svg_1">
   <path fill="#ffffff" stroke="null" d="m405.57838,11l-294.55034,0c-13.73215,0 -24.90382,11.59156 -24.90382,25.83984l0,36.19588l-14.81777,0c-7.64086,0 -13.83545,6.42742 -13.83545,14.35547s6.19459,14.35547 13.83545,14.35547l14.81777,0l0,55.59299l-14.81777,0c-7.64086,0 -13.83545,6.42742 -13.83545,14.35547s6.19459,14.35547 13.83545,14.35547l14.81777,0l0,55.59394l-14.81777,0c-7.64086,0 -13.83545,6.42742 -13.83545,14.35547s6.19459,14.35547 13.83545,14.35547l14.81777,0l0,55.59394l-14.81777,0c-7.64086,0 -13.83545,6.42742 -13.83545,14.35547s6.19459,14.35547 13.83545,14.35547l14.81777,0l0,55.59299l-14.81777,0c-7.64086,0 -13.83545,6.42742 -13.83545,14.35547s6.19459,14.35547 13.83545,14.35547l14.81777,0l0,36.19588c0,14.24828 11.17167,25.83984 24.90382,25.83984l294.55034,0c24.23418,0 43.95062,-20.45654 43.95062,-45.60254l0,-398.79492c0,-25.146 -19.71552,-45.60254 -43.95062,-45.60254zm16.27972,444.39745c0,9.31383 -7.30235,16.8916 -16.27972,16.8916l-291.78325,0l0,-33.32478l14.81777,0c7.64086,0 13.83545,-6.42742 13.83545,-14.35547s-6.19459,-14.35547 -13.83545,-14.35547l-14.81777,0l0,-55.59299l14.81777,0c7.64086,0 13.83545,-6.42742 13.83545,-14.35547s-6.19459,-14.35547 -13.83545,-14.35547l-14.81777,0l0,-55.59394l14.81777,0c7.64086,0 13.83545,-6.42742 13.83545,-14.35547s-6.19459,-14.35547 -13.83545,-14.35547l-14.81777,0l0,-55.59394l14.81777,0c7.64086,0 13.83545,-6.42742 13.83545,-14.35547s-6.19459,-14.35547 -13.83545,-14.35547l-14.81777,0l0,-55.59299l14.81777,0c7.64086,0 13.83545,-6.42742 13.83545,-14.35547s-6.19459,-14.35547 -13.83545,-14.35547l-14.81777,0l0,-33.32478l291.78325,0c8.97644,0 16.27972,7.57682 16.27972,16.8916l0,398.79492z" id="svg_2"/>
   <path fill="#ffffff" stroke="null" d="m366.54764,410.25333l-65.9988,0c-7.64086,0 -13.83545,6.42742 -13.83545,14.35547s6.19459,14.35547 13.83545,14.35547l65.9988,0c7.64086,0 13.83545,-6.42742 13.83545,-14.35547s-6.19459,-14.35547 -13.83545,-14.35547z" id="svg_3"/>
   <path fill="#ffffff" stroke="null" d="m366.54764,73.03572l-169.12089,0c-7.64086,0 -13.83545,6.42742 -13.83545,14.35547l0,77.89469c0,7.92805 6.19459,14.35547 13.83545,14.35547l169.12089,0c7.64086,0 13.83545,-6.42742 13.83545,-14.35547l0,-77.89469c0,-7.92805 -6.19459,-14.35547 -13.83545,-14.35547zm-13.83545,77.89469l-141.44998,0l0,-49.18375l141.44998,0l0,49.18375z" id="svg_4"/>
  </g>
 </g>
接下来，将其转换为可以直接在`@icon`后使用的格式，即 **Data URI** 格式。使用在线工具[在线SVG转DataURL - UU在线工具](https://uutool.cn/svg2datauri/)自动转化。

![](data:image/svg+xml;charset=utf-8;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1MTIiIGhlaWdodD0iNTEyIiBlbmFibGUtYmFja2dyb3VuZD0ibmV3IDAgMCA1MTIgNTEyIj4KIDxnPgogIDx0aXRsZT5MYXllciAxPC90aXRsZT4KICA8cmVjdCBpZD0ic3ZnXzUiIGhlaWdodD0iNTcxLjk5OTk4IiB3aWR0aD0iNTk2Ljk5OTk4IiB5PSItNDAuMzMzMzMiIHg9Ii02MS4wMDAwMSIgc3Ryb2tlPSIjMDAwIiBmaWxsPSIjMDA3ZmZmIi8+CiAgPGcgc3Ryb2tlPSJudWxsIiBpZD0ic3ZnXzEiPgogICA8cGF0aCBmaWxsPSIjZmZmZmZmIiBzdHJva2U9Im51bGwiIGQ9Im00MDUuNTc4MzgsMTFsLTI5NC41NTAzNCwwYy0xMy43MzIxNSwwIC0yNC45MDM4MiwxMS41OTE1NiAtMjQuOTAzODIsMjUuODM5ODRsMCwzNi4xOTU4OGwtMTQuODE3NzcsMGMtNy42NDA4NiwwIC0xMy44MzU0NSw2LjQyNzQyIC0xMy44MzU0NSwxNC4zNTU0N3M2LjE5NDU5LDE0LjM1NTQ3IDEzLjgzNTQ1LDE0LjM1NTQ3bDE0LjgxNzc3LDBsMCw1NS41OTI5OWwtMTQuODE3NzcsMGMtNy42NDA4NiwwIC0xMy44MzU0NSw2LjQyNzQyIC0xMy44MzU0NSwxNC4zNTU0N3M2LjE5NDU5LDE0LjM1NTQ3IDEzLjgzNTQ1LDE0LjM1NTQ3bDE0LjgxNzc3LDBsMCw1NS41OTM5NGwtMTQuODE3NzcsMGMtNy42NDA4NiwwIC0xMy44MzU0NSw2LjQyNzQyIC0xMy44MzU0NSwxNC4zNTU0N3M2LjE5NDU5LDE0LjM1NTQ3IDEzLjgzNTQ1LDE0LjM1NTQ3bDE0LjgxNzc3LDBsMCw1NS41OTM5NGwtMTQuODE3NzcsMGMtNy42NDA4NiwwIC0xMy44MzU0NSw2LjQyNzQyIC0xMy44MzU0NSwxNC4zNTU0N3M2LjE5NDU5LDE0LjM1NTQ3IDEzLjgzNTQ1LDE0LjM1NTQ3bDE0LjgxNzc3LDBsMCw1NS41OTI5OWwtMTQuODE3NzcsMGMtNy42NDA4NiwwIC0xMy44MzU0NSw2LjQyNzQyIC0xMy44MzU0NSwxNC4zNTU0N3M2LjE5NDU5LDE0LjM1NTQ3IDEzLjgzNTQ1LDE0LjM1NTQ3bDE0LjgxNzc3LDBsMCwzNi4xOTU4OGMwLDE0LjI0ODI4IDExLjE3MTY3LDI1LjgzOTg0IDI0LjkwMzgyLDI1LjgzOTg0bDI5NC41NTAzNCwwYzI0LjIzNDE4LDAgNDMuOTUwNjIsLTIwLjQ1NjU0IDQzLjk1MDYyLC00NS42MDI1NGwwLC0zOTguNzk0OTJjMCwtMjUuMTQ2IC0xOS43MTU1MiwtNDUuNjAyNTQgLTQzLjk1MDYyLC00NS42MDI1NHptMTYuMjc5NzIsNDQ0LjM5NzQ1YzAsOS4zMTM4MyAtNy4zMDIzNSwxNi44OTE2IC0xNi4yNzk3MiwxNi44OTE2bC0yOTEuNzgzMjUsMGwwLC0zMy4zMjQ3OGwxNC44MTc3NywwYzcuNjQwODYsMCAxMy44MzU0NSwtNi40Mjc0MiAxMy44MzU0NSwtMTQuMzU1NDdzLTYuMTk0NTksLTE0LjM1NTQ3IC0xMy44MzU0NSwtMTQuMzU1NDdsLTE0LjgxNzc3LDBsMCwtNTUuNTkyOTlsMTQuODE3NzcsMGM3LjY0MDg2LDAgMTMuODM1NDUsLTYuNDI3NDIgMTMuODM1NDUsLTE0LjM1NTQ3cy02LjE5NDU5LC0xNC4zNTU0NyAtMTMuODM1NDUsLTE0LjM1NTQ3bC0xNC44MTc3NywwbDAsLTU1LjU5Mzk0bDE0LjgxNzc3LDBjNy42NDA4NiwwIDEzLjgzNTQ1LC02LjQyNzQyIDEzLjgzNTQ1LC0xNC4zNTU0N3MtNi4xOTQ1OSwtMTQuMzU1NDcgLTEzLjgzNTQ1LC0xNC4zNTU0N2wtMTQuODE3NzcsMGwwLC01NS41OTM5NGwxNC44MTc3NywwYzcuNjQwODYsMCAxMy44MzU0NSwtNi40Mjc0MiAxMy44MzU0NSwtMTQuMzU1NDdzLTYuMTk0NTksLTE0LjM1NTQ3IC0xMy44MzU0NSwtMTQuMzU1NDdsLTE0LjgxNzc3LDBsMCwtNTUuNTkyOTlsMTQuODE3NzcsMGM3LjY0MDg2LDAgMTMuODM1NDUsLTYuNDI3NDIgMTMuODM1NDUsLTE0LjM1NTQ3cy02LjE5NDU5LC0xNC4zNTU0NyAtMTMuODM1NDUsLTE0LjM1NTQ3bC0xNC44MTc3NywwbDAsLTMzLjMyNDc4bDI5MS43ODMyNSwwYzguOTc2NDQsMCAxNi4yNzk3Miw3LjU3NjgyIDE2LjI3OTcyLDE2Ljg5MTZsMCwzOTguNzk0OTJ6IiBpZD0ic3ZnXzIiLz4KICAgPHBhdGggZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJudWxsIiBkPSJtMzY2LjU0NzY0LDQxMC4yNTMzM2wtNjUuOTk4OCwwYy03LjY0MDg2LDAgLTEzLjgzNTQ1LDYuNDI3NDIgLTEzLjgzNTQ1LDE0LjM1NTQ3czYuMTk0NTksMTQuMzU1NDcgMTMuODM1NDUsMTQuMzU1NDdsNjUuOTk4OCwwYzcuNjQwODYsMCAxMy44MzU0NSwtNi40Mjc0MiAxMy44MzU0NSwtMTQuMzU1NDdzLTYuMTk0NTksLTE0LjM1NTQ3IC0xMy44MzU0NSwtMTQuMzU1NDd6IiBpZD0ic3ZnXzMiLz4KICAgPHBhdGggZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJudWxsIiBkPSJtMzY2LjU0NzY0LDczLjAzNTcybC0xNjkuMTIwODksMGMtNy42NDA4NiwwIC0xMy44MzU0NSw2LjQyNzQyIC0xMy44MzU0NSwxNC4zNTU0N2wwLDc3Ljg5NDY5YzAsNy45MjgwNSA2LjE5NDU5LDE0LjM1NTQ3IDEzLjgzNTQ1LDE0LjM1NTQ3bDE2OS4xMjA4OSwwYzcuNjQwODYsMCAxMy44MzU0NSwtNi40Mjc0MiAxMy44MzU0NSwtMTQuMzU1NDdsMCwtNzcuODk0NjljMCwtNy45MjgwNSAtNi4xOTQ1OSwtMTQuMzU1NDcgLTEzLjgzNTQ1LC0xNC4zNTU0N3ptLTEzLjgzNTQ1LDc3Ljg5NDY5bC0xNDEuNDQ5OTgsMGwwLC00OS4xODM3NWwxNDEuNDQ5OTgsMGwwLDQ5LjE4Mzc1eiIgaWQ9InN2Z180Ii8+CiAgPC9nPgogPC9nPgoKPC9zdmc+)



### 6、创建一个唤出笔记本的标识

我们需要一个拥有以下功能的标识：

- 在浏览器页面的边框处，并始终位于页面最上方。
- 点击后会唤出笔记本。
- 拥有一些简单的动画效果。
- 随页面滚动时不改变标识的位置。

首先要知道如何使用 JavaScript 创建并插入 HTML 元素。

查阅了[HTML DOM insertAdjacentHTML() 方法 - 菜鸟教程](https://www.cainiaojc.com/jsref/elem_insertadjacenthtml.html)，[HTML DOM querySelector() 方法 | 菜鸟教程](https://www.runoob.com/jsref/met-document-queryselector.html)。

```JS
document.querySelector("body").insertAdjacentHTML("afterend", "<div><p>Hello world</p></div>");
//表示在<body>元素后插入<div>元素。先用querySelector()获取<body>元素的document，再用insertAdjacentHTML(,)插入元素。
```

现在我们要将这个元素置于我们希望它存在的位置，为此，我们需要了解如何利用脚本改变元素的 CSS 样式，以及如何书写 CSS。

设置位置查阅的资料：[CSS position 属性 | 菜鸟教程](https://www.runoob.com/cssref/pr-class-position.html)、[CSS bottom 属性 | 菜鸟教程](https://www.runoob.com/cssref/pr-pos-bottom.html)、[使用css，如何把div设置为圆形-百度经验](https://jingyan.baidu.com/article/f3ad7d0fa974c749c3345bff.html#:~:text=不需要使用图片，直接使用div%2Bcss就可以创建一个圆形了，下面来看一下是怎么创建的。 先创建一个div，有一个circle样式的欧泉。 为div创建样式，添加border边框，长度和宽度。,运行页面，帽泛现在div是一个四方形的形状。 再在样式里添加一个border-radius边框弧度的样式，设置为30像素。 运行页面，可以看到div现在差不多是一个圆形了。)、[CSS border 属性 | 菜鸟教程](https://www.runoob.com/cssref/pr-border.html)

```JS
    document.querySelector("body").insertAdjacentHTML("afterbegin",'<div id="nicoBt"><p>helloworld</></div>');
    //表示在<body>元素后插入<div>元素
    var nicoButton = document.getElementById("nicoBt");
    //var 表示定义变量，根据getElementById()利用id找到<div>元素
    var nicoButtonStyle = "\
    position: fixed;\
    right: 1%;\
    bottom:80%;\
    width: 44px;\
    height: 44px;\
    border: 2px solid #D3D3D3;\
    border-radius: 50%;\
    background: rgb(0, 127, 255);\
    z-index: 2147483647;\
    ";
    //第一句表示依照浏览器边框定位，right与bottom定义位置，width与height定义长宽，border用于定义边框，border-radius用于实现圆形效果,z-index定义了元素的图层高度，设置一个很大的数字可以保证其置于其他图像上方。
    //定义<div>元素的CSS样式，输入字符串时进行换行操作,在每行末尾加上\
    //末尾的;可加可不加
    nicoButton.setAttribute("style",nicoButtonStyle);
    //setAttribute(,)可以改变元素属性，用来改变nicoButton的CSS样式

```

现在我们把这个<div>元素改写为一个按钮，把图标插入进去。

```JS
var htmlNicoButton = '\
<div id="nicoBt">\
		<img src="图标URL">\
</div>\
';
document.querySelector("body").insertAdjacentHTML("afterbegin",htmlNicoButton);
//以下略
```

2024/12/9

-----

```CSS
    position: absolute;/*使用相对位置*/
    top: 50%;/*竖直方向上一半*/
    left: 50%;/*水平方向上一半*/
    transform: translate(-50%, -50%);/*x,y方向上均往回移动自身的一般*/
```

使用上面的方法把图像居中，参考：[CSS3 transform 属性 | 菜鸟教程](https://www.runoob.com/cssref/css3-pr-transform.html)

发现存在<iframe>时会添加很多的标识，希望只在主页面添加，加上判断：

```JS
    if (window.self === window.top) {
        document.querySelector("body").insertAdjacentHTML("afterend",htmlNicoButton);
    }
```

参考了[JavaScript 比较和逻辑运算符 | 菜鸟教程](https://www.runoob.com/js/js-comparisons.html)、[Window self 属性 | 菜鸟教程](https://www.runoob.com/jsref/prop-win-self.html)

下面我们要让鼠标悬停在标识上方时有一定的反馈效果，这里利用了`addEventListener()`设置两个效果，参考了[HTML DOM addEventListener() 方法 | 菜鸟教程](https://www.runoob.com/jsref/met-document-addeventlistener.html)。

```js
    nicoButton.addEventListener("mouseover", function () { //光标移动到图标上，执行函数
        nicoButton.style.width = "55px";
        nicoButton.style.height = "55px";
        //大小改变
        nicoButton.style.cursor = "pointer";
        //鼠标光标从箭头改编为小手
    });

    nicoButton.addEventListener("mouseout", function () { //光标移开
        nicoButton.style.width = "48px";
        nicoButton.style.height = "48px";
        nicoButton.style.cursor = "";
        //变回
    });

```

### 7、创建笔记本！

使用开源项目 [Vditor](https://github.com/Vanessa219/vditor) ,根据开发者文档尝试在 HTML 中引入 vditor 。

```html
<!-- ⚠️生产环境请指定版本号，如 https://unpkg.com/vditor@x.x.x/dist... -->
<link rel="stylesheet" href="https://unpkg.com/vditor/dist/index.css" />
<script src="https://unpkg.com/vditor/dist/index.min.js"></script>
```

把这行代码写入<head>中：

```js
    document.querySelector("head").insertAdjacentHTML("afterbegin",headVditorCode);
```

**Q5：之前讲过用`@require`加载脚本，这里可以那样做吗？**

> 可以，且**更推荐使用`@require`的方式**，因为如果你在插入资源后立即使用 Vditor，可能会因为资源未加载完成而报错，并且动态插入 HTML 字符串不够直观，可能会增加代码阅读和维护的难度。
>
> 但是**`@require`只能用来加载 JS 而不能用于 CSS **使用`GM_addStyle`可以解决这一问题。
>
> ```js
> // ==UserScript==
> // @name         Vditor Integration with CSS
> // @namespace    http://tampermonkey.net/
> // @version      1.0
> // @description  Integrate Vditor
> // @author       Your Name
> // @match        *://*/*
> // @require      https://cdn.jsdelivr.net/npm/vditor/dist/index.min.js
> // @grant        GM_addStyle
> // ==/UserScript==
> 
> // 使用 GM_addStyle 插入 CSS 样式
> GM_addStyle(`
> @import url('https://cdn.jsdelivr.net/npm/vditor/dist/index.css');
> `);
> ```
>
> 如果你坚持使用动态插入方式，建议优化为分步加载，避免时序问题：
>
> ```javascript
> // 动态加载 CSS
> var link = document.createElement('link');
> link.rel = 'stylesheet';
> link.href = 'https://unpkg.com/vditor/dist/index.css';
> document.head.appendChild(link);
> 
> // 动态加载 JS
> var script = document.createElement('script');
> script.src = 'https://unpkg.com/vditor/dist/index.min.js';
> script.onload = function () {
>     // 确保 Vditor 加载完成后再初始化
>     new Vditor('editor', {
>         height: 300,
>         placeholder: 'Write something...',
>     });
> };
> document.head.appendChild(script);
> ```
>
> 这种方式更易维护，且避免 HTML 字符串操作的潜在问题。

创建一个<div>作为我们的笔记本框：

```js
    var nicoNoteDiv = document.createElement("div");//这里用document.creatElement()创建元素。ps.比最开始进步了
    nicoNoteDiv.setAttribute("id","nicoNoteDiv");
```

用点击事件呼出编辑框，并让图标不透明度降低（参考[css中让元素消失的方法_transition visibility 无效-CSDN博客](https://blog.csdn.net/qq_43205326/article/details/110207160)）：

```js
    nicoButton.addEventListener("click", function () {
     document.querySelector("html").appendChild(nicoNoteDiv);//用点击事件呼出编辑框,添加在 nicoBt 后面
     nicoButton.style.opacity="0.3"; //图标不透明度降低
    });
//这里用 elementA.appendChild(elemenetB)：表明在A内最后添加B元素
```

下面我们来设计这个`nicoNoteDiv`除了最基本的长宽位置之外，我们希望它可以允许自己通过拖拽调节大小和位置（似乎略有些麻烦）。

2024/12/10
